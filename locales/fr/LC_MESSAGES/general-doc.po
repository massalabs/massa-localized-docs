# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Massa Labs
# This file is distributed under the same license as the Massa package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Massa \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-10-20 15:57+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../general-doc/archi-conclusion.rst:2
msgid "Conclusion"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:4
msgid ""
"There are many more details and specific mechanisms that are not "
"described in this short introduction, but it gives a good overview of the"
" architecture and should help to get inside the code of the Massa Node."
msgstr ""

#: ../../general-doc/archi-conclusion.rst:6
msgid "Topics that were not handled here include:"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:8
msgid ""
"operations fees (each operation provides a fee and block factories will "
"tend to favor operations with the highest fees for inclusion in blocks "
"first), and how they are shared between block producers and endorsers"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:9
msgid "ledger size limitation and the cost of storage"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:10
msgid "slashing and node banning"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:11
msgid ""
"execution stack within smart contracts and what permissions smart "
"contracts have in terms of ledger read/write access, based on their "
"address"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:12
msgid "details about the opcodes of the Massa WASM virtual machine"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:13
msgid ""
"analysis of potential attacks, like multistaking (when a block producer "
"produces several blocks in the same slot)"
msgstr ""

#: ../../general-doc/archi-conclusion.rst:15
msgid ""
"For further references and technical details, you can find more "
"information in the `whitepaper <https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/archi-global.rst:2
msgid "Architecture"
msgstr ""

#: ../../general-doc/archi-global.rst:4
msgid ""
"This is the diagram of the architecture of the software modules involved "
"in building, endorsing and propagating blocks. The bottom part "
"corresponds to a single process running in a node and is in charge of the"
" execution and consensus building. The pool and factories, referred to as"
" \"factory\", can be potentially running in a different process or be "
"part of the node. Overall, each of the modules described here runs inside"
" one or more threads attached to their respective executable process (NB:"
" the factory/node separation is not yet implemented, but will be soon)."
msgstr ""

#: ../../general-doc/archi-global.rst:12
msgid ""
"We will explain below the different modules present in this diagram, and "
"simulate the production of an operation to show how it navigates through "
"the different modules to better understand how blocks are produced and "
"propagated."
msgstr ""

#: ../../general-doc/archi-global.rst:16
msgid "API Module"
msgstr ""

#: ../../general-doc/archi-global.rst:18
msgid ""
"The API Module is the public window of the node to the rest of the world."
" It allows for interactions with external clients or factories via a JSON"
" RPC protocol."
msgstr ""

#: ../../general-doc/archi-global.rst:20
msgid "The API includes interfaces to do the following:"
msgstr ""

#: ../../general-doc/archi-global.rst:22
msgid "publish a new operation from a client"
msgstr ""

#: ../../general-doc/archi-global.rst:23
msgid "query the network about balances or ledger status"
msgstr ""

#: ../../general-doc/archi-global.rst:24
msgid ""
"allow for synchronization between remote pool/factory nodes and the "
"consensus nodes, by sending/asking for blocks, best parents, draws, etc."
msgstr ""

#: ../../general-doc/archi-global.rst:27
msgid "Protocol/Network Module"
msgstr ""

#: ../../general-doc/archi-global.rst:29
msgid ""
"The Protocol/Network Module implements the protocol connecting consensus "
"nodes. This protocol is supported by a binary and optimized transport "
"layer and does not use JSON RPC."
msgstr ""

#: ../../general-doc/archi-global.rst:32
msgid ""
"The Protocol/Network Module will relay all operations/blocks creation and"
" propagation, so that all other nodes in the network can synchronize "
"their internal state, following a type of gossip synchronization "
"protocol."
msgstr ""

#: ../../general-doc/archi-global.rst:35
msgid ""
"The type of messages that can be relayed via the Protocol/Network Module "
"include:"
msgstr ""

#: ../../general-doc/archi-global.rst:37
msgid ""
"blocks/operations/endorsements propagation (either getting in or out of "
"the node)"
msgstr ""

#: ../../general-doc/archi-global.rst:38
msgid "nodes ban requests"
msgstr ""

#: ../../general-doc/archi-global.rst:39
msgid "connectivity infos/stats"
msgstr ""

#: ../../general-doc/archi-global.rst:42
msgid "Selector Module, Proof of Stake sybil resistance"
msgstr ""

#: ../../general-doc/archi-global.rst:44
msgid ""
"Every 0.5s, a new slot becomes active to receive a new block. A "
"determinist selection mechanism ensures that one of the nodes in the "
"network is elected to have the responsibility to build the block for that"
" slot. This mechanism must have several key properties:"
msgstr ""

#: ../../general-doc/archi-global.rst:48
msgid ""
"it should be sybil resistant, so that it is not possible to increase "
"one's odds of being elected by creating multiple clones of oneself "
"(sybil) without a cost that is equal or greater than the cost of "
"increasing one's odds for oneself only"
msgstr ""

#: ../../general-doc/archi-global.rst:49
msgid ""
"it should be deterministic, so that all nodes in the network will agree "
"on the result of the selection at any given time"
msgstr ""

#: ../../general-doc/archi-global.rst:50
msgid ""
"it should be fair, so that each participant has a well-defined "
"probability of being selected somehow proportional to the cost of "
"participating, and draws converge towards this probability distribution "
"over time"
msgstr ""

#: ../../general-doc/archi-global.rst:52
msgid ""
"The way sybil resistance is achieved here is via the proof of stake "
"mechanism. Nodes who want to participate in the block creation lottery "
"will have to stake \"rolls\" that they buy with Massa coins. If they try "
"to cheat by creating fake blocks or multiple blocks on the same slot, "
"their stake will be taken away from them (slashing) and they would suffer"
" the loss. The probabilistic \"surface\" of a participant is equal to its"
" total stake, which makes the creation of sybil accounts useless because "
"the stake would have to be split between them anyway."
msgstr ""

#: ../../general-doc/archi-global.rst:57
msgid ""
"The method used to draw an elected node for a given slot is simply a "
"random draw from a distribution where addresses are weighted by the "
"amount of stake (=rolls) they hold. The schema below illustrates how the "
"seed and probability distribution are built, based on past cycles (two "
"cycles are needed for the distribution update to ensure that the balance "
"finalization has occurred and the amount of rolls is accurate):"
msgstr ""

#: ../../general-doc/archi-global.rst:63
msgid ""
"The Selector Module is in charge of computing the formula and replying to"
" requests regarding what node is elected for any given slot in the "
"present or the past. The Execution Module (see below) is in charge of "
"feeding the Selector Module with updates regarding balances, needed to "
"compute the draws."
msgstr ""

#: ../../general-doc/archi-global.rst:67
msgid "Graph/Consensus Module"
msgstr ""

#: ../../general-doc/archi-global.rst:69
msgid ""
"The Consensus Module is the heart of the machinery of the Massa Network. "
"It is in charge of integrating proposed blocks into their respective "
"slots and verifying the integrity of the result. We have not yet talked "
"about the various constraints regarding block creation, and in particular"
" how parents are to be selected. In traditional blockchains, the parent "
"of a block is simply the previous valid block in the chain. In the "
"context of the Massa network and the parallel chains in the 32 threads, "
"identifying the proper parent in a given thread requires a more "
"sophisticated strategy involving the notion of block cliques."
msgstr ""

#: ../../general-doc/archi-global.rst:77
msgid "Block cliques"
msgstr ""

#: ../../general-doc/archi-global.rst:79
msgid ""
"At any given time, the set of all the blocks that have been produced and "
"propagated in the network constitutes a graph (more precisely a Directed "
"Acyclic Graph or \"DAG\"), where each block, except the genesis blocks, "
"has 32 parents. All the reasoning below can be in principle done on this "
"increasingly vast set, but in practice, we will introduce a notion of "
"\"finalized\" or \"staled\" blocks, that can be removed from the set and "
"that will allow us to work on a smaller subset of recent blocks that are "
"neither finalized nor staled, so \"pending\" blocks. This set of pending "
"blocks is all the network needs to know in order to incrementally build "
"up a consensus, therefore non-pending blocks will simply be forgotten "
"(this is a striking difference with most other blockchains that store in "
"each node the history of all past transactions). The main benefit of this"
" block pruning is to allow for some of the algorithms below, which are in"
" general NP-complete, to run fast enough on a smaller subgraph, and to "
"allow for a practical implementation."
msgstr ""

#: ../../general-doc/archi-global.rst:87
msgid ""
"Here is a simplified example of a graph of pending blocks over two "
"threads, with blocks 3 and 4 competing for slot C1 (for example as a "
"result of a multistaking attack where the block producer decided to "
"create competing blocks for the same slot). Here the letter of a slot "
"identifies it, while the number refers to its thread number:"
msgstr ""

#: ../../general-doc/archi-global.rst:93
msgid ""
"In this illustration we have shown only relevant parent links in blue, to"
" make the whole diagram more readable, but in reality, each block has 32 "
"parents, one in each of the 32 threads."
msgstr ""

#: ../../general-doc/archi-global.rst:96
msgid ""
"An important notion we will use in the following is that of "
"incompatibility between blocks. Excluding some edge cases with genesis "
"blocks, there are two sources of incompatibilities defined for blocks:"
msgstr ""

#: ../../general-doc/archi-global.rst:99
msgid ""
"**thread incompatibility**: this occurs when two blocks in a given thread"
" have the same parent in that thread."
msgstr ""

#: ../../general-doc/archi-global.rst:100
msgid ""
"**grandpa incompatibility**: this corresponds to a case with two blocks "
"B1 and B2 in threads t1 and t2, and where the block B1 in t1 has a parent"
" in t2 who is an ancestor of B2's parent in t2, and symmetrically B2's "
"parent in t1 is an ancestor of B1's parent in t1."
msgstr ""

#: ../../general-doc/archi-global.rst:102
msgid ""
"You will find a more formal mathematical definition of these "
"incompatibility notions in the `whitepaper "
"<https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/archi-global.rst:104
msgid ""
"From these definitions, you can build another graph, called the "
"incompatibility graph, which connects any two blocks that have any form "
"of incompatibility together:"
msgstr ""

#: ../../general-doc/archi-global.rst:108
msgid ""
"As you can see, some blocks are isolated and therefore compatible with "
"any other, while some are linked, because they have a form of "
"incompatibility."
msgstr ""

#: ../../general-doc/archi-global.rst:110
msgid ""
"This brings us to the notion of a maximal clique which is a subset of the"
" incompatibility graph such as none of the block members are incompatible"
" with each other (so, no internal link withing the clique), and it is "
"impossible to add an extra block to the set without introducing "
"incompatibilities. In the above example, there are three maximal cliques "
"that can be built, as illustrated below:"
msgstr ""

#: ../../general-doc/archi-global.rst:116
msgid ""
"They represent candidates to extend the set of already finalized blocks "
"into a coherent set of new blocks. All we need to add to be able to build"
" a consensus rule now is to introduce a deterministic metric to rank "
"those candidates so that nodes can independently and consistently decide "
"on which clique is the best candidate and keep building on top of it. In "
"particular, once the best maximal clique is identified, it becomes "
"trivial to define the list of the parents for a new block simply by "
"picking the oldest block from that clique in each thread."
msgstr ""

#: ../../general-doc/archi-global.rst:122
msgid ""
"The metric used in a traditional blockchain to rank competing chain "
"candidates is habitually the length of the chain, or more precisely the "
"total amount of work invested in the chain (also known as \"Nakamoto "
"consensus\"). In the case of block cliques, we will introduce a notion of"
" fitness for each block, and the fitness of the clique will simply be the"
" sum of all its block's fitness. The block fitness :math:`f(b)` is simply"
" defined as :math:`1+e`, :math:`e` being the number of endorsements "
"registered in the block."
msgstr ""

#: ../../general-doc/archi-global.rst:127
msgid ""
"Taking the maximal clique with the highest fitness (or some hash-based "
"deterministic selection in case of equality), the Graph/Consensus module "
"can define what is called the **blockclique** at the current time."
msgstr ""

#: ../../general-doc/archi-global.rst:131
msgid "Finalized blocks, stale blocks"
msgstr ""

#: ../../general-doc/archi-global.rst:133
msgid ""
"The set of pending blocks is growing each time a new block is produced "
"and added to the current set. As we mentioned previously, there is also a"
" pruning mechanism in charge of reducing the size of the graph by "
"removing blocks that are considered final, and also blocks that can be "
"considered stale and will never finalize."
msgstr ""

#: ../../general-doc/archi-global.rst:137
msgid ""
"If a block is only contained inside cliques that have a fitness lower "
"than the fitness of the blockclique (the clique with the maximal "
"fitness), minus a constant :math:`\\Delta_f^0`, then this block is "
"considered stale. Also, any new block that includes in its parents a "
"stale block is stale."
msgstr ""

#: ../../general-doc/archi-global.rst:141
msgid ""
"A block is considered final if it is part of all maximal cliques, and "
"included in at least one clique where the total sum of the fitness of all"
" its descendants is greater than :math:`\\Delta_f^0`."
msgstr ""

#: ../../general-doc/archi-global.rst:143
msgid ""
":math:`\\Delta_f^0` is defined as a constant :math:`F` multiplied by "
":math:`1+E` (:math:`E` being the total max number of endorsements in a "
"block, currently 16), and :math:`F` effectively measuring the maximum "
"span in fully endorsed blocks of a successful blockclique, or the number "
"of fully endorsed blocks by which an alternative clique can be shorter "
"than the blockclique before its blocks may be discarded as stale."
msgstr ""

#: ../../general-doc/archi-global.rst:148
msgid "Graph/Consensus Module Function"
msgstr ""

#: ../../general-doc/archi-global.rst:150
msgid ""
"The Consensus Module (formerly known as the Graph) receives new block "
"proposals, integrates them into the set of pending blocks, updating the "
"blockclique with the method explained above, and verifying the legitimacy"
" of the parenting of new blocks. It also informs other modules, like the "
"Execution module, when blocks are finalized and the corresponding ledger "
"modifications implied by their operations list should be made permanent."
msgstr ""

#: ../../general-doc/archi-global.rst:154
msgid ""
"It is also able to answer queries about the current best parents for a "
"new block (based on the current blockclique) or the list of current "
"maximal cliques."
msgstr ""

#: ../../general-doc/archi-global.rst:157
msgid "Execution Module"
msgstr ""

#: ../../general-doc/archi-global.rst:159
msgid ""
"The Execution Module is in charge of effectively executing the operations"
" contained in blocks within the current blockclique, which is provided by"
" the Graph/Consensus Module. Operations will typically modify the ledger,"
" either by changing the balances of accounts or by modifying the "
"datastore of smart contracts after the execution of some code. From an "
"implementation point of view, ledger modifications are however stored as "
"diff vs the current finalized ledger, until the corresponding blocks are "
"marked as finalized by the Graph/Consensus Module."
msgstr ""

#: ../../general-doc/archi-global.rst:165
msgid ""
"Block creators will typically need to query the Execution Module to check"
" current balances at a given slot and verify if some operations can be "
"run with sufficient funds or not, before being integrated into a new "
"block."
msgstr ""

#: ../../general-doc/archi-global.rst:168
msgid ""
"As a side note, it is also possible that blocks might include invalid "
"operations, in which case the Execution Module will simply ignore them."
msgstr ""

#: ../../general-doc/archi-global.rst:170
msgid ""
"Being the maintainer of the ledger, the Execution Module is also queried "
"about address information in general, via the API, for any Module that "
"needs it."
msgstr ""

#: ../../general-doc/archi-global.rst:172
msgid ""
"Finally, the Execution Module will inform the Selector Module when new "
"cycles are initiated as the finalization of blocks progresses."
msgstr ""

#: ../../general-doc/archi-global.rst:175
msgid "Pool Module"
msgstr ""

#: ../../general-doc/archi-global.rst:177
msgid ""
"When new pending operations reach a node, they are not immediately "
"processed but instead are stored in a pool of pending operations, to be "
"used by the Factory Module. Similarly, proposed endorsements coming from "
"the Endorsement Factory are buffered inside the pool, to be integrated "
"into new blocks by the Block Factory Module."
msgstr ""

#: ../../general-doc/archi-global.rst:180
msgid ""
"The origin of pending operations or endorsements inside the pool can be "
"internal to the factory process or could come from remote nodes via the "
"API Module. Similarly, locally produced pending endorsements are "
"broadcasted via a gossip protocol to other pools via the API Module."
msgstr ""

#: ../../general-doc/archi-global.rst:183
msgid ""
"Note that operations stored in the Pool are naturally discarded after a "
"certain time, since operations come with an expiration date in the "
"`expiration_period` field. Still, some potential attacks can occur by "
"trying to flood the pool with high fees operations that have no chance of"
" being executed because the corresponding account does not have the "
"required funds. Discussing about countermeasure for this is beyond the "
"scope of this introduction."
msgstr ""

#: ../../general-doc/archi-global.rst:188
msgid "Block/Endorsement Factory Module"
msgstr ""

#: ../../general-doc/archi-global.rst:190
msgid ""
"The Block Factory Module is in charge of creating new blocks when the "
"corresponding node address has been designated to be the block creator "
"for a given slot. This information is provided to the Factory Module from"
" the Selector Module via the API Module."
msgstr ""

#: ../../general-doc/archi-global.rst:193
msgid ""
"The Block Factory Module also needs information about the best parents "
"(made of the latest blocks in each thread in the blockclique) from the "
"Graph/Consensus Module. These parents will be included in the newly "
"created block. Balance information, in order to assess the validity of "
"pending operations, is obtained from the Execution Module, which "
"maintains the ledger state from the point of view of the slot where the "
"new block is supposed to be created."
msgstr ""

#: ../../general-doc/archi-global.rst:197
msgid ""
"The Block Factory Module picks pending operations from the Pool Module. "
"Note that the Block Factory will regularly query the Execution Module "
"about finalized and executed operations, and internally cleanup "
"operations that have been handled."
msgstr ""

#: ../../general-doc/archi-global.rst:201
msgid ""
"Finally, the Block Factory will query the Pool Module and pick pending "
"endorsements corresponding to the best parents that are selected for the "
"block."
msgstr ""

#: ../../general-doc/archi-global.rst:203
msgid ""
"With this information, it is able to forge a new block that will then be "
"propagated to the Graph/Consensus Module via the API Module, as well as "
"to other nodes via gossip, to maintain a global synchronized state."
msgstr ""

#: ../../general-doc/archi-global.rst:206
msgid ""
"The Endorsement Factory Module works in a similar manner, requesting the "
"Selector Module to find out when it has been designated to be an "
"endorsement producer, then feeding new endorsements to the Pool Module "
"and the API Module for global synchronization."
msgstr ""

#: ../../general-doc/archi-global.rst:210
msgid "Operation lifecycle"
msgstr ""

#: ../../general-doc/archi-global.rst:212
msgid ""
"We have now all the elements and vocabulary in place to explore the "
"lifecycle of an operation within the network, from creation to permanent "
"execution in a finalized block."
msgstr ""

#: ../../general-doc/archi-global.rst:214
msgid ""
"Operations originate externally from a client that is forging the "
"operation, for example: a transaction or a smart contract code execution."
" The client will have to know the IP address of a Massa Node (this can be"
" either because it is a node itself and will simply use localhost, or via"
" some maintained list of known nodes and/or some browser plugin), and "
"will then send the operation to the API Module."
msgstr ""

#: ../../general-doc/archi-global.rst:218
msgid ""
"When an operation is made available in a given node, it will be "
"broadcasted to all other nodes via the Protocol/Network Module and to "
"factories via the API Module, so that it will eventually end up in all "
"the Pool Modules of the network."
msgstr ""

#: ../../general-doc/archi-global.rst:221
msgid ""
"Let's assume we just got a code execution operation from an external "
"client. Let's suppose the client knows a particular node, which is "
"running its block factory on the same machine, and sends the operation to"
" this node. These are the different steps of the operation processing "
"that will occur, as illustrated in the schema below:"
msgstr ""

#: ../../general-doc/archi-global.rst:225
msgid ""
"The operation enters the node via the API Module (the operation path is "
"marked in blue)"
msgstr ""

#: ../../general-doc/archi-global.rst:226
msgid ""
"The API Module forwards the operation to the Pool Module and broadcasts "
"it to other nodes via the Protocol/Network Module. Other nodes hearing "
"about it will also broadcast it (gossip protocol), and feed it to their "
"Pool Module, unless they are pure consensus nodes without factories"
msgstr ""

#: ../../general-doc/archi-global.rst:227
msgid "At that stage, the operation sits in the Pool Modules of most nodes"
msgstr ""

#: ../../general-doc/archi-global.rst:228
msgid ""
"The Selector Module elects a particular node to handle the block "
"production of the next current slot"
msgstr ""

#: ../../general-doc/archi-global.rst:229
msgid ""
"The elected node Block Factory finds out about its election by querying a"
" Selector Module (via the API Module)"
msgstr ""

#: ../../general-doc/archi-global.rst:230
msgid ""
"It starts building a block by picking up pending operations in the Pool "
"Module. The original operation is eventually picked and integrated into "
"the block. We will now follow the block around (the block path is marked "
"in green)"
msgstr ""

#: ../../general-doc/archi-global.rst:231
msgid ""
"The newly produced block is sent via the API to remote or local nodes, to"
" reach the Graph/Consensus Module"
msgstr ""

#: ../../general-doc/archi-global.rst:232
msgid ""
"The new block is processed by the Graph/Consensus Module to be included "
"into the pending blocks DAG and potentially integrated into a new "
"blockclique"
msgstr ""

#: ../../general-doc/archi-global.rst:233
msgid ""
"The Graph/Consensus Module sends the new block to other nodes via the "
"Protocol/Network Module, to ensure synchronization of the information in "
"the network. The new block reaching other nodes is similarly going to be "
"integrated into their Graph/Consensus Module"
msgstr ""

#: ../../general-doc/archi-global.rst:234
msgid ""
"In general, the blockclique will be extended with the new block and so "
"will reach the Execution Module from the Graph/Consensus Module via the "
"notification of a new blockclique. Eventually, it will also be notified "
"as a final block if it gets finalized"
msgstr ""

#: ../../general-doc/archi-global.rst:235
msgid ""
"The Execution Module will run the blocks that are part of the updated "
"blockclique, so the original block will eventually be executed. Within "
"the block is the original operation that was originally sent and that "
"will then be applied to the ledger for potential modifications. At this "
"stage, the modifications are not permanent and simply stored in a diff "
"compared to the finalized ledger"
msgstr ""

#: ../../general-doc/archi-global.rst:236
msgid ""
"Eventually, the block will be marked as final and the ledger "
"modification, including the operation changes, will become final in the "
"finalized ledger."
msgstr ""

#: ../../general-doc/archi-intro.rst:5 ../../general-doc/autonomous-sc.rst:10
msgid "Introduction"
msgstr ""

#: ../../general-doc/archi-intro.rst:7
msgid ""
"We will describe in this document the global architecture of a Massa "
"Node, from the ground up, and introduce relevant definitions and "
"concepts."
msgstr ""

#: ../../general-doc/archi-intro.rst:9
msgid ""
"The goal of the Massa network is to build a consensus between **nodes** "
"to gather and order **blocks** that contains ordered lists of "
"**operations**. An operation ultimate purpose once executed is to act as "
"transitions for the global network state, called the **ledger**."
msgstr ""

#: ../../general-doc/archi-intro.rst:12
msgid ""
"Operations are produced by external clients and sent to the Massa network"
" via a node. Some operations are containing code to be run as **smart "
"contracts**, enabling complex programmatic modifications of the ledger. "
"Nodes will gather all the pending operations and group them to produce "
"blocks. Each block contains a finite set of operations, limited by the "
"fact that each block has a limited amount of space available to store "
"operations. Traditional blockchains will then typically link blocks one "
"after the other (including a hash of the previous block in the block "
"header), to materialize their temporal ordering. However, unlike "
"traditional blockchains, Massa blocks are not simply chained one after "
"the other, but organized into a more complex spatio-temporal structure, "
"which allows for parallelization and increased performances."
msgstr ""

#: ../../general-doc/archi-intro.rst:20
msgid ""
"Instead of one chain, there are several threads (T=32) of chains running "
"in parallel, with blocks equally spread on each thread over time, and "
"stored inside **slots** that are spaced at fixed time intervals:"
msgstr ""

#: ../../general-doc/archi-intro.rst:25
msgid ""
"The time between two slots located on the same thread is called a "
"**period** and lasts 16s (conventionally called :math:`t_0`). "
"Corresponding slots in threads are slightly shifted in time relative to "
"one another, by one period divided by the number of threads, which is "
"16s/32 = 0.5s, so that a period contains exactly 32 slots equally spaced "
"over the 32 threads. A **cycle** is defined as the succession of 128 "
"periods and so lasts a bit more than 34min. Periods are numbered by "
"increments of one, so can be used together with a thread number to "
"uniquely identify a block slot. Period 0 is the genesis and contains "
"genesis blocks with no parents."
msgstr ""

#: ../../general-doc/archi-intro.rst:32
msgid ""
"The job of the Massa nodes network is to essentially collectively fill up"
" slots with valid blocks. To do so, at each interval of 0.5s, a specific "
"node in the network is elected to be allowed to create a block (more "
"about the selection process below, and the proof of stake sybil "
"resistance mechanism), and will be rewarded if it creates a valid block "
"in time. It is also possible that a node misses its opportunity to create"
" the block, in which case the slot will remain empty (this is called a "
"**block miss**)."
msgstr ""

#: ../../general-doc/archi-intro.rst:38
msgid ""
"In traditional blockchains, blocks are simply referencing their unique "
"parent, forming a chain. In the case of Massa, each block is referencing "
"one parent block in each thread (so, 32 parents). Here is an example "
"illustrated with one particular block:"
msgstr ""

#: ../../general-doc/archi-intro.rst:44
msgid ""
"Let's introduce some relevant definitions and concepts generally "
"necessary to understand how the Massa network operates. We will then "
"explain the node architecture and how the whole system works."
msgstr ""

#: ../../general-doc/archi-intro.rst:48
msgid "Address"
msgstr ""

#: ../../general-doc/archi-intro.rst:50
msgid ""
"Each account in Massa has a public and private key associated with it. "
"This is how messages can be signed and identity enforced."
msgstr ""

#: ../../general-doc/archi-intro.rst:53
msgid "The address of an account is simply the hash of its public key."
msgstr ""

#: ../../general-doc/archi-intro.rst:56
msgid "Ledger"
msgstr ""

#: ../../general-doc/archi-intro.rst:58
msgid ""
"The ledger is a map that stores a global mapping between addresses and "
"information related to these addresses. It is replicated in each node and"
" the consensus building mechanism ensures that agreement on what "
"operations have been finalized (and in what order) will be reached over "
"the whole network. The ledger is the state of the Massa network, and "
"fundamentally operations (see below) are requests to modify the ledger."
msgstr ""

#: ../../general-doc/archi-intro.rst:62
msgid "The information stored in the ledger with each address is the following:"
msgstr ""

#: ../../general-doc/archi-intro.rst:65
msgid "**Ledger information associated with each address**"
msgstr ""

#: ../../general-doc/archi-intro.rst:67
msgid "``balance``"
msgstr ""

#: ../../general-doc/archi-intro.rst:67
msgid "The amount of Massa coins owned by the address"
msgstr ""

#: ../../general-doc/archi-intro.rst:68 ../../general-doc/archi-intro.rst:144
msgid "``bytecode``"
msgstr ""

#: ../../general-doc/archi-intro.rst:68
msgid ""
"When the address references a smart contract, this is the compiled code "
":raw-html:`<br/>` corresponding to the smart contract (typically contains"
" several functions that act as :raw-html:`<br/>` API entry points for the"
" smart contract)"
msgstr ""

#: ../../general-doc/archi-intro.rst:70
msgid "``datastore``"
msgstr ""

#: ../../general-doc/archi-intro.rst:70
msgid ""
"A key/value map that can store any persistent data related to a smart "
":raw-html:`<br/>` contract, its variables, etc"
msgstr ""

#: ../../general-doc/archi-intro.rst:76
msgid "Smart Contract"
msgstr ""

#: ../../general-doc/archi-intro.rst:78
msgid ""
"Smart contracts are a piece of code that can be run inside the Massa "
"virtual machine and which can modify the ledger, accept incoming requests"
" through a public interface (via smart contract operations). One "
"particularity of Massa smart contracts compared to other blockchain smart"
" contracts is their ability to wake up by themselves independently of an "
"exterior request on their interface. This allows more autonomy and less "
"dependency on external centralized services."
msgstr ""

#: ../../general-doc/archi-intro.rst:84
msgid ""
"Smart contracts are currently written in assemblyscript, a stricter "
"derivation from typescript, which is itself a type-safe version of "
"javascript. AssemblyScript compiles to web assembly bytecode (wasm). "
"Massa nodes Execution Module runs such bytecode. Smart contracts have "
"access to their own datastore, so they can modify the ledger."
msgstr ""

#: ../../general-doc/archi-intro.rst:89
msgid "Operation"
msgstr ""

#: ../../general-doc/archi-intro.rst:91
msgid ""
"Fundamentally, the point of the Massa network is to gather, order and "
"execute operations, recorded inside blocks that are located in slots. "
"There are three types of operations: transactions, roll operations, and "
"smart contract code execution. The general structure of an operation is "
"the following, and the different types of operations differ by their "
"payload:"
msgstr ""

#: ../../general-doc/archi-intro.rst:96
msgid "**Operation header**"
msgstr ""

#: ../../general-doc/archi-intro.rst:98 ../../general-doc/archi-intro.rst:175
msgid "``creator_public_key``"
msgstr ""

#: ../../general-doc/archi-intro.rst:98
msgid "The public key of the operation creator (64 bytes)"
msgstr ""

#: ../../general-doc/archi-intro.rst:99
msgid "``expiration_period``"
msgstr ""

#: ../../general-doc/archi-intro.rst:99
msgid "Period after which the operation is expired"
msgstr ""

#: ../../general-doc/archi-intro.rst:100
msgid "``max_gas``"
msgstr ""

#: ../../general-doc/archi-intro.rst:100
msgid "The maximum gas spendable for this operation"
msgstr ""

#: ../../general-doc/archi-intro.rst:101
msgid "``fee``"
msgstr ""

#: ../../general-doc/archi-intro.rst:101
msgid "The amount of fees the creator is willing to pay"
msgstr ""

#: ../../general-doc/archi-intro.rst:102
msgid "``payload``"
msgstr ""

#: ../../general-doc/archi-intro.rst:102
msgid "The content of the operation (see below)"
msgstr ""

#: ../../general-doc/archi-intro.rst:103 ../../general-doc/archi-intro.rst:180
msgid "``signature``"
msgstr ""

#: ../../general-doc/archi-intro.rst:103
msgid ""
"signature of all the above with the private key of :raw-html:`<br/>` the "
"operation creator"
msgstr ""

#: ../../general-doc/archi-intro.rst:108
msgid "Transactions operations"
msgstr ""

#: ../../general-doc/archi-intro.rst:110
msgid ""
"Transactions are operations that move native Massa coins between "
"addresses. Here is the corresponding payload:"
msgstr ""

#: ../../general-doc/archi-intro.rst:113
msgid "**Transaction payload**"
msgstr ""

#: ../../general-doc/archi-intro.rst:115
msgid "``amount``"
msgstr ""

#: ../../general-doc/archi-intro.rst:115
msgid "The amount of coins to transfer"
msgstr ""

#: ../../general-doc/archi-intro.rst:116
msgid "``destination_address``"
msgstr ""

#: ../../general-doc/archi-intro.rst:116
msgid "The address of the recipient"
msgstr ""

#: ../../general-doc/archi-intro.rst:120
msgid "Buy/Sell Rolls operations"
msgstr ""

#: ../../general-doc/archi-intro.rst:122
msgid ""
"Rolls are staking tokens that participants can buy or sell with native "
"coins (more about staking below). This is done via special operations, "
"with a simple payload:"
msgstr ""

#: ../../general-doc/archi-intro.rst:126
msgid "**Roll buy/sell payload**"
msgstr ""

#: ../../general-doc/archi-intro.rst:128
msgid "``nb_of_rolls``"
msgstr ""

#: ../../general-doc/archi-intro.rst:128
msgid "The number of rolls to buy or to sell"
msgstr ""

#: ../../general-doc/archi-intro.rst:133
msgid "Smart Contract operations"
msgstr ""

#: ../../general-doc/archi-intro.rst:135
msgid ""
"Smart Contracts are pieces of code that can be run inside the Massa "
"virtual machine. There are two ways of calling for the execution of code:"
msgstr ""

#: ../../general-doc/archi-intro.rst:137
msgid "Direct execution of bytecode"
msgstr ""

#: ../../general-doc/archi-intro.rst:139
msgid ""
"In this case, the code is provided in the operation payload and executed "
"directly:"
msgstr ""

#: ../../general-doc/archi-intro.rst:142
msgid "**Execute SC payload**"
msgstr ""

#: ../../general-doc/archi-intro.rst:144
msgid "The bytecode to run (in the context of the caller address)"
msgstr ""

#: ../../general-doc/archi-intro.rst:147
msgid "Smart Contract function call"
msgstr ""

#: ../../general-doc/archi-intro.rst:149
msgid ""
"Here, the code is indirectly called via the call to an existing smart "
"contract function, together with the required parameters:"
msgstr ""

#: ../../general-doc/archi-intro.rst:152
msgid "**Call SC**"
msgstr ""

#: ../../general-doc/archi-intro.rst:154
msgid "``target_address``"
msgstr ""

#: ../../general-doc/archi-intro.rst:154
msgid "The address of the targeted smart contract"
msgstr ""

#: ../../general-doc/archi-intro.rst:155
msgid "``target_fun``"
msgstr ""

#: ../../general-doc/archi-intro.rst:155
msgid "The function that is called"
msgstr ""

#: ../../general-doc/archi-intro.rst:156
msgid "``params``"
msgstr ""

#: ../../general-doc/archi-intro.rst:156
msgid "The parameters of the function call"
msgstr ""

#: ../../general-doc/archi-intro.rst:160
msgid "Block"
msgstr ""

#: ../../general-doc/archi-intro.rst:162
msgid ""
"A block is a data structure built by nodes and its function it to "
"aggregate several operations. As explained above, for each new slot that "
"becomes active, a particular node in the network is elected in a "
"deterministic way with the task of creating the block that will be stored"
" in that slot (more about this in the description of the Selector Module "
"below). A block from a given thread can only contain operations "
"originating from a `creator_public_key` whose hash's five first bits "
"designate the corresponding thread, thus implicitly avoiding collisions "
"in operations integrated into parallel threads."
msgstr ""

#: ../../general-doc/archi-intro.rst:168
msgid "The content of a block is as follows:"
msgstr ""

#: ../../general-doc/archi-intro.rst:171
msgid "**Block header**"
msgstr ""

#: ../../general-doc/archi-intro.rst:173
msgid "``slot``"
msgstr ""

#: ../../general-doc/archi-intro.rst:173
msgid ""
"A description of the block slot, defined by a couple (period, thread) "
"that :raw-html:`<br/>` uniquely identify it"
msgstr ""

#: ../../general-doc/archi-intro.rst:175
msgid "The public key of the block creator (64 bytes)"
msgstr ""

#: ../../general-doc/archi-intro.rst:176
msgid "``parents``"
msgstr ""

#: ../../general-doc/archi-intro.rst:176
msgid ""
"A list of the 32 parents of the block, one parent per thread (parent "
"blocks are :raw-html:`<br/>` identified by the block hash)"
msgstr ""

#: ../../general-doc/archi-intro.rst:178
msgid "``endorsements``"
msgstr ""

#: ../../general-doc/archi-intro.rst:178
msgid ""
"A list of the 16 endorsements for the block (more about endorsements "
"below)"
msgstr ""

#: ../../general-doc/archi-intro.rst:179
msgid "``operations_hash``"
msgstr ""

#: ../../general-doc/archi-intro.rst:179
msgid ""
"A hash of all the operations included in the block (=hash of the block "
"body below)"
msgstr ""

#: ../../general-doc/archi-intro.rst:180
msgid "signature of all the above with the private key of the block creator"
msgstr ""

#: ../../general-doc/archi-intro.rst:182
msgid "**Block body**"
msgstr ""

#: ../../general-doc/archi-intro.rst:184
msgid "``operations``"
msgstr ""

#: ../../general-doc/archi-intro.rst:184
msgid "The list of all operations included in the block"
msgstr ""

#: ../../general-doc/archi-intro.rst:187
msgid ""
"Endorsements are optional inclusion in the block, but their inclusion is "
"incentivized for block creators. They are validations of the fact that "
"the parent block on the thread of the block is the best parent that could"
" have been chosen, done by other nodes that have also been "
"deterministically selected via the proof of stake probability "
"distribution (see below). A comprehensive description of endorsements can"
" be found `here <https://github.com/massalabs/massa/blob/main/docs"
"/technical-doc/Endorsements.rst>`_, so we will not go further into "
"details in the context of this introduction."
msgstr ""

#: ../../general-doc/architecture.rst:7
msgid "Massa's Architecture"
msgstr ""

#: ../../general-doc/autonomous-sc.rst:5
msgid "Massa's Autonomous Smart Contracts"
msgstr ""

#: ../../general-doc/autonomous-sc.rst:13
msgid "Issues with current smart contracts"
msgstr ""

#: ../../general-doc/autonomous-sc.rst:15
msgid ""
"The ability to perform autonomous tasks is widespread in any modern IT "
"infrastructure. However it is totally absent from decentralized "
"applications that run on public blockchains such as Ethereum: without "
"external calls, smart contracts as they exist in all public blockchains "
"cannot perform operations."
msgstr ""

#: ../../general-doc/autonomous-sc.rst:20
msgid ""
"Many decentralized protocol rely on recurrent trigger of certain "
"fonctions to function properly. This is the case for instance for the "
"MakerDAO protocol. In this protocol, users can lock ETH as a collateral "
"to take out loans. If the price of the ETH decreases below a threshold, "
"then the position can become under-collateralized. To ensure that the "
"protocol behaves correctly and that funds from lenders cannot be lost, "
"such positions must be liquidated. Such liquidations are currently "
"performed by organizations or individuals running bots, usualy on some "
"centralized cloud services."
msgstr ""

#: ../../general-doc/autonomous-sc.rst:29
msgid "The need for a reliable automation mechanism"
msgstr ""

#: ../../general-doc/autonomous-sc.rst:31
msgid ""
"There are countless of applications that rely on recurrent calls to "
"function properly. As a result, a lot of time and energy has been spent "
"trying to develop more reliable networks of bots to guarantee that "
"transactions are always executed when needed. However, as those solutions"
" are inherently off-chain, there's no guarantee that the execution will "
"be effectively triggered. And when those bots `fail to execute such "
"transactions <https://insights.glassnode.com/what-really-happened-to-"
"makerdao/>`_, those protocols are at risk (and the applications built on "
"top of them)."
msgstr ""

#: ../../general-doc/autonomous-sc.rst:40
msgid "Autonomous Smart Contracts"
msgstr ""

#: ../../general-doc/autonomous-sc.rst:42
msgid ""
"Massa's **Autonomous Smart Contracts** solve the issues of lacking "
"reliability, sophistication and centralization around dapps that want to "
"offer automated smart contract executions on behalf of their users. "
"Autonomous Smart Contracts introduces self wakeup capabilities to smart "
"contracts. In practice, smart contracts can be programmed to perform "
"arbitrary operations in the future, recurrently."
msgstr ""

#: ../../general-doc/autonomous-sc.rst:48
msgid ""
"Such a capability opens the door to multiple applications, from automated"
" liquidation of under-collateralized positions on lending protocols to "
"on-chain trading bots or ever evolving NFTs."
msgstr ""

#: ../../general-doc/decentralized-web.rst:5
msgid "Massa's Decentralized web"
msgstr ""

#: ../../general-doc/decentralized-web.rst:10
msgid "Rationale"
msgstr ""

#: ../../general-doc/decentralized-web.rst:12
msgid ""
"The *code is law* rule is a cornerstone of DeFi. It states among other "
"things that once successfully audited, a program can remain trusted. This"
" implies that the program of a successfully audited smart contract may "
"never be unexpectedly changed by an outsider (note that contracts that "
"modify their own code during runtime cannot be trusted this way in the "
"first place, but this is visible in the code audit). Popular ETH smart "
"contracts essentially follow that rule."
msgstr ""

#: ../../general-doc/decentralized-web.rst:18
msgid ""
"However, most DeFi web3 apps such as `app.uniswap.org "
"<https://app.uniswap.org/>`_ are typically used through an otherwise "
"normal website that talks to a browser plugin (typically `Metamask "
"<https://github.com/MetaMask/metamask-extension>`_) allowing the webpage "
"to interact with the user's wallet and the blockchain. The website that "
"serves as an entry point to the dapp is neither decentralized nor "
"immutable-once-audited, thus breaking the very foundations of DeFi "
"security. And that's how you get into situations like `this one "
"<https://www.theverge.com/2021/12/2/22814849/badgerdao-defi-120-million-"
"hack-bitcoin-ethereum>`_."
msgstr ""

#: ../../general-doc/decentralized-web.rst:24
msgid ""
"The goal here is to allow addresses on Massa to store not only a balance,"
" bytecode and a datastore, but also named files. Those files must remain "
"small, or storing them will cost a lot to their owner. Any address, "
"through bytecode execution, can initialize, read and write the \"files\" "
"part just like it would with the datastore. The reason why we don't reuse"
" the datastore for this, outside of the risk of key collisions, is for "
"easier auditing: if the code never writes into its own bytecode nor its "
"filestore after deployment, it is safe to assume that the stored website "
"can't change anymore. That's it from the point of view of the node."
msgstr ""

#: ../../general-doc/decentralized-web.rst:31
msgid ""
"That way, Massa allows deploying fully decentralized code-is-law apps, as"
" it was meant to be!"
msgstr ""

#: ../../general-doc/decentralized-web.rst:33
msgid ""
"To close the loop, we can imagine dumping a copy of the source code of "
"Massa and surrounding tools in the filestore of an on-chain smart "
"contract."
msgstr ""

#: ../../general-doc/decentralized-web.rst:36
msgid "Filestore"
msgstr ""

#: ../../general-doc/decentralized-web.rst:38
msgid ""
"From the point of the node, this functions just like another extra binary"
" datastore in the ledger, but indexed by a max-255-char string (instead "
"of hash) and we call it the \"filestore\"."
msgstr ""

