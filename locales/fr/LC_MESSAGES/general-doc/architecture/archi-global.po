# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Massa Labs
# This file is distributed under the same license as the Massa Localized
# Docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Massa Localized Docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-09 00:51+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../general-doc/architecture/archi-global.rst:2
#: 879cffca1b314bf8b79ca665e140fb30
msgid "Architecture"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:4
#: 649513b6fdbb4ee1b5ffb95e0fc2b315
msgid ""
"This is the diagram of the architecture of the software modules involved "
"in building, endorsing and propagating blocks. The bottom part "
"corresponds to a single process running in a node and is in charge of the"
" execution and consensus building. The pool and factories, referred to as"
" \"factory\", can be potentially running in a different process or be "
"part of the node. Overall, each of the modules described here runs inside"
" one or more threads attached to their respective executable process (NB:"
" the factory/node separation is not yet implemented, but will be soon)."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:12
#: e841d69870ad4572b44d80bdd54674cf
msgid ""
"We will explain below the different modules present in this diagram, and "
"simulate the production of an operation to show how it navigates through "
"the different modules to better understand how blocks are produced and "
"propagated."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:16
#: 0220db2595be405fbd9792ca490089fb
msgid "Bootstrap Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:18
#: 16cc5492117b455bb12baafc5d1d95cc
msgid ""
"The bootstrap module is responsible for the initial synchronization of "
"the node with the rest of the network. It is responsible for downloading "
"the list of peers, the current graph of blocks, the ledger, the "
"asynchronous pool, state of the Proof-of-Stake and latests executed "
"operations."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:22
#: 7bb179dba2ed4f81bacebaaf1e2a1ed3
msgid ""
"The bootstrap will be done from a server that is listed on the "
"configuration of the node. Bootstrap is the entry point of the network so"
" you have to be careful on which node you connect to avoid downloading "
"malicious data."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:26
#: 9334a0e34398476c8c9dde6f36fcfa6d
msgid "API Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:28
#: aab0e737473b4dfa8444d5ac789df693
msgid ""
"The API Module is the public window of the node to the rest of the world."
" It allows for interactions with external clients or factories via a JSON"
" RPC protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:31
#: df1041263ad0400ca2afc966e131410f
msgid "The API includes interfaces to do the following:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:33
#: 7cd688134da849e0b93db321b78dba74
msgid "publish a new operation from a client"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:34
#: 4241bfdd73164c50a931d3ebf074a739
msgid "query the network about balances or ledger status"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:35
#: 6929084a47b14ffd85ddcd9282a4822c
msgid ""
"allow for synchronization between remote pool/factory nodes and the "
"consensus nodes, by sending/asking for blocks, best parents, draws, etc."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:39
#: 673fe241bb364612b3b05faf1d6d1de1
msgid "Protocol/Network Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:41
#: 013a7e193b9e400e821139bf86d7675b
msgid ""
"The Protocol/Network Module implements the protocol connecting consensus "
"nodes. This protocol is supported by a binary and optimized transport "
"layer and does not use JSON RPC."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:44
#: 8c78734516184303905a2912ce06f24f
msgid ""
"The Protocol/Network Module will relay all operations/blocks creation and"
" propagation, so that all other nodes in the network can synchronize "
"their internal state, following a type of gossip synchronization "
"protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:47
#: d5992a37700c4c03a7e3916cbb93f630
msgid ""
"The type of messages that can be relayed via the Protocol/Network Module "
"include:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:49
#: c1f62f1985424c3d8ee4354dd1ba8036
msgid ""
"blocks/operations/endorsements propagation (either getting in or out of "
"the node)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:50
#: 80841f5ca718417cae418bcb8b133455
msgid "nodes ban requests"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:51
#: 0531f56c4cef4283988605c81643c2e5
msgid "connectivity infos/stats"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:54
#: fa6be02d314944de996e2ee18ebbb6ba
msgid "Selector Module, Proof of Stake sybil resistance"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:56
#: 993b85daf4e743798666caa09d1b24b7
msgid ""
"Every 0.5s, a new slot becomes active to receive a new block. A "
"determinist selection mechanism ensures that one of the nodes in the "
"network is elected to have the responsibility to build the block for that"
" slot. This mechanism must have several key properties:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:60
#: 063261fc3d3a45308fe4ae7ee40c54d3
msgid ""
"it should be sybil resistant, so that it is not possible to increase "
"one's odds of being elected by creating multiple clones of oneself "
"(sybil) without a cost that is equal or greater than the cost of "
"increasing one's odds for oneself only"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:63
#: 13a377be1fa146c6a76df6d5f46780b8
msgid ""
"it should be deterministic, so that all nodes in the network will agree "
"on the result of the selection at any given time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:65
#: ebadbbd460274bc7a5391d159e152c9e
msgid ""
"it should be fair, so that each participant has a well-defined "
"probability of being selected somehow proportional to the cost of "
"participating, and draws converge towards this probability distribution "
"over time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:68
#: 10a405b74ed54a3d811031acf153a3f5
msgid ""
"The way sybil resistance is achieved here is via the proof of stake "
"mechanism. Nodes who want to participate in the block creation lottery "
"will have to stake \"rolls\" that they buy with Massa coins. If they try "
"to cheat by creating fake blocks or multiple blocks on the same slot, "
"their stake will be taken away from them (slashing) and they would suffer"
" the loss. The probabilistic \"surface\" of a participant is equal to its"
" total stake, which makes the creation of sybil accounts useless because "
"the stake would have to be split between them anyway."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:75
#: 536d23a7fd844966b8bf5bcfae6d8d5f
msgid ""
"The method used to draw an elected node for a given slot is simply a "
"random draw from a distribution where addresses are weighted by the "
"amount of stake (=rolls) they hold. The schema below illustrates how the "
"seed and probability distribution are built, based on past cycles (two "
"cycles are needed for the distribution update to ensure that the balance "
"finalization has occurred and the amount of rolls is accurate):"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:83
#: d4531bd4454748c99062dfaf91a745b7
msgid ""
"The Selector Module is in charge of computing the formula and replying to"
" requests regarding what node is elected for any given slot in the "
"present or the past. The Execution Module (see below) is in charge of "
"feeding the Selector Module with updates regarding balances, needed to "
"compute the draws."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:89
#: 57a57b608c774c9f86dea6722d583e06
msgid "Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:91
#: 686ddc3efbbc4d118a3ac4e3bb06a916
msgid ""
"The Consensus Module is the heart of the machinery of the Massa Network. "
"It is in charge of integrating proposed blocks into their respective "
"slots and verifying the integrity of the result. We have not yet talked "
"about the various constraints regarding block creation, and in particular"
" how parents are to be selected. In traditional blockchains, the parent "
"of a block is simply the previous valid block in the chain. In the "
"context of the Massa network and the parallel chains in the 32 threads, "
"identifying the proper parent in a given thread requires a more "
"sophisticated strategy involving the notion of block cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:101
#: f1c8ba1e9fc94af498391bb146355f22
msgid "Block cliques"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:103
#: 084c85dd59a746af9a142bce2aa2ac20
msgid ""
"At any given time, the set of all the blocks that have been produced and "
"propagated in the network constitutes a graph (more precisely a Directed "
"Acyclic Graph or \"DAG\"), where each block, except the genesis blocks, "
"has 32 parents. All the reasoning below can be in principle done on this "
"increasingly vast set, but in practice, we will introduce a notion of "
"\"finalized\" or \"staled\" blocks, that can be removed from the set and "
"that will allow us to work on a smaller subset of recent blocks that are "
"neither finalized nor staled, so \"pending\" blocks. This set of pending "
"blocks is all the network needs to know in order to incrementally build "
"up a consensus, therefore non-pending blocks will simply be forgotten "
"(this is a striking difference with most other blockchains that store in "
"each node the history of all past transactions). The main benefit of this"
" block pruning is to allow for some of the algorithms below, which are in"
" general NP-complete, to run fast enough on a smaller subgraph, and to "
"allow for a practical implementation."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:115
#: 4c9ae4a56c374cc1926cc86c087741f5
msgid ""
"Here is a simplified example of a graph of pending blocks over two "
"threads, with blocks 3 and 4 competing for slot C1 (for example as a "
"result of a multistaking attack where the block producer decided to "
"create competing blocks for the same slot). Here the letter of a slot "
"identifies it, while the number refers to its thread number:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:122
#: fb3255fc309545fc803681ce663594d3
msgid ""
"In this illustration we have shown only relevant parent links in blue, to"
" make the whole diagram more readable, but in reality, each block has 32 "
"parents, one in each of the 32 threads."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:125
#: 9ba22f608c134c27b545afa412494846
msgid ""
"An important notion we will use in the following is that of "
"incompatibility between blocks. Excluding some edge cases with genesis "
"blocks, there are two sources of incompatibilities defined for blocks:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:128
#: fa9c14786a834bdaaa899890aba2f252
msgid ""
"**thread incompatibility**: this occurs when two blocks in a given thread"
" have the same parent in that thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:129
#: 482dc91b34564ed8a1926ea9e8d72bed
msgid ""
"**grandpa incompatibility**: this corresponds to a case with two blocks "
"B1 and B2 in threads t1 and t2, and where the block B1 in t1 has a parent"
" in t2 who is an ancestor of B2's parent in t2, and symmetrically B2's "
"parent in t1 is an ancestor of B1's parent in t1."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:133
#: 9c617c2adc9844d089c852058e6dc79d
msgid ""
"You will find a more formal mathematical definition of these "
"incompatibility notions in the `whitepaper "
"<https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:136
#: 509f510581554c1181ab9f47fdd6df7f
msgid ""
"From these definitions, you can build another graph, called the "
"incompatibility graph, which connects any two blocks that have any form "
"of incompatibility together:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:141
#: 26c186b99df543339c33edf7e16fc577
msgid ""
"As you can see, some blocks are isolated and therefore compatible with "
"any other, while some are linked, because they have a form of "
"incompatibility."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:144
#: 4d6a286395bf4240a5fc785dc7a2d02e
msgid ""
"This brings us to the notion of a maximal clique which is a subset of the"
" incompatibility graph such as none of the block members are incompatible"
" with each other (so, no internal link within the clique), and it is "
"impossible to add an extra block to the set without introducing "
"incompatibilities. In the above example, there are three maximal cliques "
"that can be built, as illustrated below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:151
#: 75799de1459b4991b7b83dea3448fb71
msgid ""
"They represent candidates to extend the set of already finalized blocks "
"into a coherent set of new blocks. All we need to add to be able to build"
" a consensus rule now is to introduce a deterministic metric to rank "
"those candidates so that nodes can independently and consistently decide "
"on which clique is the best candidate and keep building on top of it. In "
"particular, once the best maximal clique is identified, it becomes "
"trivial to define the list of the parents for a new block simply by "
"picking the oldest block from that clique in each thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:158
#: 360ed9be23ab488084a3b83720ee4930
msgid ""
"The metric used in a traditional blockchain to rank competing chain "
"candidates is habitually the length of the chain, or more precisely the "
"total amount of work invested in the chain (also known as \"Nakamoto "
"consensus\"). In the case of block cliques, we will introduce a notion of"
" fitness for each block, and the fitness of the clique will simply be the"
" sum of all its block's fitness. The block fitness :math:`f(b)` is simply"
" defined as :math:`1+e`, :math:`e` being the number of endorsements "
"registered in the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:165
#: 3ae7b06db89747b48c69c3dc5fc22526
msgid ""
"Taking the maximal clique with the highest fitness (or some hash-based "
"deterministic selection in case of equality), the Graph/Consensus module "
"can define what is called the **blockclique** at the current time."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:169
#: b44e1bcb0b124083b91b82564488e722
msgid "Finalized blocks, stale blocks"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:171
#: 5cbfcf462ebf4351927b14e9c836b2f5
msgid ""
"The set of pending blocks is growing each time a new block is produced "
"and added to the current set. As we mentioned previously, there is also a"
" pruning mechanism in charge of reducing the size of the graph by "
"removing blocks that are considered final, and also blocks that can be "
"considered stale and will never finalize."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:175
#: 9293c7e19ef84222b605fda34f6f0e40
msgid ""
"If a block is only contained inside cliques that have a fitness lower "
"than the fitness of the blockclique (the clique with the maximal "
"fitness), minus a constant :math:`\\Delta_f^0`, then this block is "
"considered stale. Also, any new block that includes in its parents a "
"stale block is stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:179
#: 33dee473a1a74486a51ccf1a7a98310e
msgid ""
"A block is considered final if it is part of all maximal cliques, and "
"included in at least one clique where the total sum of the fitness of all"
" its descendants is greater than :math:`\\Delta_f^0`."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:182
#: ff1be5687e2e42669e12647290c12972
msgid ""
":math:`\\Delta_f^0` is defined as a constant :math:`F` multiplied by "
":math:`1+E` (:math:`E` being the total max number of endorsements in a "
"block, currently 16), and :math:`F` effectively measuring the maximum "
"span in fully endorsed blocks of a successful blockclique, or the number "
"of fully endorsed blocks by which an alternative clique can be shorter "
"than the blockclique before its blocks may be discarded as stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:189
#: 6a5f2762f5a24d39aef47bc9f69e7b6f
msgid "Graph/Consensus Module Function"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:191
#: 70fdb3d7ec874f1880ac518062f73cfd
msgid ""
"The Consensus Module (formerly known as the Graph) receives new block "
"proposals, integrates them into the set of pending blocks, updating the "
"blockclique with the method explained above, and verifying the legitimacy"
" of the parenting of new blocks. It also informs other modules, like the "
"Execution module, when blocks are finalized and the corresponding ledger "
"modifications implied by their operations list should be made permanent."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:197
#: 473ed9b7188941a1a41ac844c3f62e12
msgid ""
"It is also able to answer queries about the current best parents for a "
"new block (based on the current blockclique) or the list of current "
"maximal cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:201
#: 89ab2ffc18d44c9cb61bc7896c5bc8f3
msgid "Execution Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:203
#: 57f60c5b27e74221a5ee10dd18123c77
msgid ""
"The Execution Module is in charge of effectively executing the operations"
" contained in blocks within the current blockclique, which is provided by"
" the Graph/Consensus Module. Operations will typically modify the ledger,"
" either by changing the balances of accounts or by modifying the "
"datastore of smart contracts after the execution of some code. From an "
"implementation point of view, ledger modifications are however stored as "
"diff vs the current finalized ledger, until the corresponding blocks are "
"marked as finalized by the Graph/Consensus Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:209
#: 0efa92a4ec4f4dff9e160a8129d4bc80
msgid ""
"Block creators will typically need to query the Execution Module to check"
" current balances at a given slot and verify if some operations can be "
"run with sufficient funds or not, before being integrated into a new "
"block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:212
#: 51ae0821336c4bfaaefb14e779d75707
msgid ""
"As a side note, it is also possible that blocks might include invalid "
"operations, in which case the Execution Module will simply ignore them."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:215
#: c3a308b89a34490686d22655454edaa6
msgid ""
"Being the maintainer of the ledger, the Execution Module is also queried "
"about address information in general, via the API, for any Module that "
"needs it."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:218
#: 896d915742de4d47884dbab2fc2dc9d5
msgid ""
"Finally, the Execution Module will inform the Selector Module when new "
"cycles are initiated as the finalization of blocks progresses."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:222
#: 412380828c7840c9bfe4cad23c05f893
msgid "Pool Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:224
#: 8610fbf2f163423890315ef44752ef7f
msgid ""
"When new pending operations reach a node, they are not immediately "
"processed but instead are stored in a pool of pending operations, to be "
"used by the Factory Module. Similarly, proposed endorsements coming from "
"the Endorsement Factory are buffered inside the pool, to be integrated "
"into new blocks by the Block Factory Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:229
#: e61c6839216a4b16873f0bf0a546c0e5
msgid ""
"The origin of pending operations or endorsements inside the pool can be "
"internal to the factory process or could come from remote nodes via the "
"API Module. Similarly, locally produced pending endorsements are "
"broadcasted via a gossip protocol to other pools via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:234
#: d572a7530c73413fbf6b5e7c9cd8cbea
msgid ""
"Note that operations stored in the Pool are naturally discarded after a "
"certain time, since operations come with an expiration date in the "
"`expiration_period` field. Still, some potential attacks can occur by "
"trying to flood the pool with high fees operations that have no chance of"
" being executed because the corresponding account does not have the "
"required funds. Discussing about countermeasure for this is beyond the "
"scope of this introduction."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:241
#: 4d9b326813444701baa2fb452e158ae7
msgid "Block/Endorsement Factory Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:243
#: d47677c22a184bf388259a060d177a80
msgid ""
"The Block Factory Module is in charge of creating new blocks when the "
"corresponding node address has been designated to be the block creator "
"for a given slot. This information is provided to the Factory Module from"
" the Selector Module via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:247
#: 9c467f3511e24b6e802bb25e1b5ccae9
msgid ""
"The Block Factory Module also needs information about the best parents "
"(made of the latest blocks in each thread in the blockclique) from the "
"Graph/Consensus Module. These parents will be included in the newly "
"created block. Balance information, in order to assess the validity of "
"pending operations, is obtained from the Execution Module, which "
"maintains the ledger state from the point of view of the slot where the "
"new block is supposed to be created."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:253
#: d65852ca8a1c4bbf817e0ae9ace72981
msgid ""
"The Block Factory Module picks pending operations from the Pool Module. "
"Note that the Block Factory will regularly query the Execution Module "
"about finalized and executed operations, and internally cleanup "
"operations that have been handled."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:257
#: 4b49e527bb2940d4b1f3890ccde63af1
msgid ""
"Finally, the Block Factory will query the Pool Module and pick pending "
"endorsements corresponding to the best parents that are selected for the "
"block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:260
#: a08c4dbf2bc944d0a75bd7ce0fd0e9cc
msgid ""
"With this information, it is able to forge a new block that will then be "
"propagated to the Graph/Consensus Module via the API Module, as well as "
"to other nodes via gossip, to maintain a global synchronized state."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:263
#: cdc88fc242cf4d6591e9d802f9af7488
msgid ""
"The Endorsement Factory Module works in a similar manner, requesting the "
"Selector Module to find out when it has been designated to be an "
"endorsement producer, then feeding new endorsements to the Pool Module "
"and the API Module for global synchronization."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:268
#: e1c45e2506f54e25a53bc5cc3d7b856e
msgid "Operation lifecycle"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:270
#: bfbf13a8193f4926a34d4fa4154db874
msgid ""
"We have now all the elements and vocabulary in place to explore the "
"lifecycle of an operation within the network, from creation to permanent "
"execution in a finalized block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:273
#: 8b07e4dd09374a4d9db40ca4df644b09
msgid ""
"Operations originate externally from a client that is forging the "
"operation, for example: a transaction or a smart contract code execution."
" The client will have to know the IP address of a Massa Node (this can be"
" either because it is a node itself and will simply use localhost, or via"
" some maintained list of known nodes and/or some browser plugin), and "
"will then send the operation to the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:279
#: 4c8d1f38e8c949f7b1309a02802bccdb
msgid ""
"When an operation is made available in a given node, it will be "
"broadcasted to all other nodes via the Protocol/Network Module and to "
"factories via the API Module, so that it will eventually end up in all "
"the Pool Modules of the network."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:283
#: 4f1a2c2d412b4b0fab3268551c42d9d7
msgid ""
"Let's assume we just got a code execution operation from an external "
"client. Let's suppose the client knows a particular node, which is "
"running its block factory on the same machine, and sends the operation to"
" this node. These are the different steps of the operation processing "
"that will occur, as illustrated in the schema below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:287
#: 129645036ca145889722abfbea1e1591
msgid ""
"The operation enters the node via the API Module (the operation path is "
"marked in blue)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:288
#: 832f0c42a37541048ceedb42b42fd32b
msgid ""
"The API Module forwards the operation to the Pool Module and broadcasts "
"it to other nodes via the Protocol/Network Module. Other nodes hearing "
"about it will also broadcast it (gossip protocol), and feed it to their "
"Pool Module, unless they are pure consensus nodes without factories"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:291
#: 9efed331bc3f41ce8c04515e41adf1ac
msgid "At that stage, the operation sits in the Pool Modules of most nodes"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:292
#: a6995ae58d3d4649a2dcb2c5dd970752
msgid ""
"The Selector Module elects a particular node to handle the block "
"production of the next current slot"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:293
#: 039a75113f70443a8a2c9eae3484a996
msgid ""
"The elected node Block Factory finds out about its election by querying a"
" Selector Module (via the API Module)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:294
#: 49afd40ca94945d18e0f54ab8ac2f1ab
msgid ""
"It starts building a block by picking up pending operations in the Pool "
"Module. The original operation is eventually picked and integrated into "
"the block. We will now follow the block around (the block path is marked "
"in green)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:297
#: c3975f05334443e0960c31252aab744f
msgid ""
"The newly produced block is sent via the API to remote or local nodes, to"
" reach the Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:298
#: 3c121dd6b7364aca8b6fa6fe77129abd
msgid ""
"The new block is processed by the Graph/Consensus Module to be included "
"into the pending blocks DAG and potentially integrated into a new "
"blockclique"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:300
#: 1c1ceba3defd4cd783e42fe30c9d59a9
msgid ""
"The Graph/Consensus Module sends the new block to other nodes via the "
"Protocol/Network Module, to ensure synchronization of the information in "
"the network. The new block reaching other nodes is similarly going to be "
"integrated into their Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:303
#: 7582f57b0f8142888fa234c785cfe021
msgid ""
"In general, the blockclique will be extended with the new block and so "
"will reach the Execution Module from the Graph/Consensus Module via the "
"notification of a new blockclique. Eventually, it will also be notified "
"as a final block if it gets finalized."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:306
#: a87a08e3e0b4488f9e810144c6322530
msgid ""
"The Execution Module will run the blocks that are part of the updated "
"blockclique, so the original block will eventually be executed. Within "
"the block is the original operation that was originally sent and that "
"will then be applied to the ledger for potential modifications. At this "
"stage, the modifications are not permanent and simply stored in a diff "
"compared to the finalized ledger"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:310
#: 915f3d93b1f7426bb3f7d567612ecc76
msgid ""
"Eventually, the block will be marked as final and the ledger "
"modification, including the operation changes, will become final in the "
"finalized ledger."
msgstr ""

#~ msgid ""
#~ "In general, the blockclique will be "
#~ "extended with the new block and so"
#~ " will reach the Execution Module from"
#~ " the Graph/Consensus Module via the "
#~ "notification of a new blockclique. "
#~ "Eventually, it will also be notified "
#~ "as a final block if it gets "
#~ "finalized"
#~ msgstr ""

#~ msgid ""
#~ "The bootstrap module is responsible for"
#~ " the initial synchronization of the "
#~ "node with the rest of the network."
#~ " It is responsible for downloading "
#~ "the list of peers, the current "
#~ "graph of blocks, the ledger, the "
#~ "asyncronous pool, state of the Proof-"
#~ "of-Stake and latests executed "
#~ "operations."
#~ msgstr ""

#~ msgid ""
#~ "This brings us to the notion of"
#~ " a maximal clique which is a "
#~ "subset of the incompatibility graph such"
#~ " as none of the block members "
#~ "are incompatible with each other (so,"
#~ " no internal link withing the "
#~ "clique), and it is impossible to "
#~ "add an extra block to the set "
#~ "without introducing incompatibilities. In the"
#~ " above example, there are three "
#~ "maximal cliques that can be built, "
#~ "as illustrated below:"
#~ msgstr ""

