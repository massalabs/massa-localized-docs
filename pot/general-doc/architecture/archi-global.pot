# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Massa Labs
# This file is distributed under the same license as the Massa Localized Docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Massa Localized Docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-23 00:52+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../general-doc/architecture/archi-global.rst:2
#: 72aa9731cb1f4288804b331b4ca6bb3c
msgid "Architecture"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:4
#: 6eeb15f94e3f4467b658cd1cd210ed6f
msgid "This is the diagram of the architecture of the software modules involved in building, endorsing and propagating blocks. The bottom part corresponds to a single process running in a node and is in charge of the execution and consensus building. The pool and factories, referred to as \"factory\", can be potentially running in a different process or be part of the node. Overall, each of the modules described here runs inside one or more threads attached to their respective executable process (NB: the factory/node separation is not yet implemented, but will be soon)."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:12
#: 17521631b7cf462e8bad2bf79c75cfa0
msgid "We will explain below the different modules present in this diagram, and simulate the production of an operation to show how it navigates through the different modules to better understand how blocks are produced and propagated."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:16
#: ba492385cda842688b1a95b4e5036f83
msgid "Bootstrap Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:18
#: bd3a22efeed84962bf25433e9927a769
msgid "The bootstrap module is responsible for the initial synchronization of the node with the rest of the network. It is responsible for downloading the list of peers, the current graph of blocks, the ledger, the asynchronous pool, state of the Proof-of-Stake and latests executed operations."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:22
#: 24d25cd7c67e4032b9c4ac8db6c6c815
msgid "The bootstrap will be done from a server that is listed on the configuration of the node. Bootstrap is the entry point of the network so you have to be careful on which node you connect to avoid downloading malicious data."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:26
#: 0f00e4bbb7a0467699df978e2449a133
msgid "API Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:28
#: 9b1e02026fab4d738cb24ebfaac489f8
msgid "The API Module is the public window of the node to the rest of the world. It allows for interactions with external clients or factories via a JSON RPC protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:31
#: 1ee0e0bd368447f899b2e441d5a8e26d
msgid "The API includes interfaces to do the following:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:33
#: 850cca53ab854089b6aa725c2ee060b1
msgid "publish a new operation from a client"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:34
#: aa70c08921704afd98d842a44ea59bd2
msgid "query the network about balances or ledger status"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:35
#: 9c7f506aa7f644308c04f7a8f49d63fb
msgid "allow for synchronization between remote pool/factory nodes and the consensus nodes, by sending/asking for blocks, best parents, draws, etc."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:39
#: 90380340732f4a17a066c781afa692df
msgid "Protocol/Network Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:41
#: 96e2c02a2a344049b2b4a556a8b0f097
msgid "The Protocol/Network Module implements the protocol connecting consensus nodes. This protocol is supported by a binary and optimized transport layer and does not use JSON RPC."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:44
#: 060d67cadb26423686f93ab74fda1913
msgid "The Protocol/Network Module will relay all operations/blocks creation and propagation, so that all other nodes in the network can synchronize their internal state, following a type of gossip synchronization protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:47
#: 31bf0001e5ed4216931212af96e64442
msgid "The type of messages that can be relayed via the Protocol/Network Module include:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:49
#: 9ca806822db6458e8f0d779f614b5b78
msgid "blocks/operations/endorsements propagation (either getting in or out of the node)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:50
#: 7679cb3aa66349878b804c2ca5495224
msgid "nodes ban requests"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:51
#: 853797befb7845e79f91f20786c39abb
msgid "connectivity infos/stats"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:54
#: 4af0be52c562485484a9fed0c0996c38
msgid "Selector Module, Proof of Stake sybil resistance"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:56
#: fd8997bd0b35457a803020ecdd52bfd4
msgid "Every 0.5s, a new slot becomes active to receive a new block. A determinist selection mechanism ensures that one of the nodes in the network is elected to have the responsibility to build the block for that slot. This mechanism must have several key properties:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:60
#: 8fadecd4f6e74760a87910befbdf088e
msgid "it should be sybil resistant, so that it is not possible to increase one's odds of being elected by creating multiple clones of oneself (sybil) without a cost that is equal or greater than the cost of increasing one's odds for oneself only"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:63
#: a04049feb0bf4ec8b2d73bf3d00af353
msgid "it should be deterministic, so that all nodes in the network will agree on the result of the selection at any given time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:65
#: 4444c6120bc444dd8761f303ad4f6ad8
msgid "it should be fair, so that each participant has a well-defined probability of being selected somehow proportional to the cost of participating, and draws converge towards this probability distribution over time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:68
#: 9f853ce264e74730a5bbd14b980bb70d
msgid "The way sybil resistance is achieved here is via the proof of stake mechanism. Nodes who want to participate in the block creation lottery will have to stake \"rolls\" that they buy with Massa coins. If they try to cheat by creating fake blocks or multiple blocks on the same slot, their stake will be taken away from them (slashing) and they would suffer the loss. The probabilistic \"surface\" of a participant is equal to its total stake, which makes the creation of sybil accounts useless because the stake would have to be split between them anyway."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:74
#: d3774a7a185c43f28d0e67093a28df90
msgid "The method used to draw an elected node for a given slot is simply a random draw from a distribution where addresses are weighted by the amount of stake (=rolls) they hold. The schema below illustrates how the seed and probability distribution are built, based on past cycles (two cycles are needed for the distribution update to ensure that the balance finalization has occurred and the amount of rolls is accurate):"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:81
#: a4d9a471aae84e5db641881f50114413
msgid "The Selector Module is in charge of computing the formula and replying to requests regarding what node is elected for any given slot in the present or the past. The Execution Module (see below) is in charge of feeding the Selector Module with updates regarding balances, needed to compute the draws."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:86
#: e313c889beba474fb9f10ccf3e6e279f
msgid "Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:88
#: c662c308df254b97815c56aa80d78178
msgid "The Consensus Module is the heart of the machinery of the Massa Network. It is in charge of integrating proposed blocks into their respective slots and verifying the integrity of the result. We have not yet talked about the various constraints regarding block creation, and in particular how parents are to be selected. In traditional blockchains, the parent of a block is simply the previous valid block in the chain. In the context of the Massa network and the parallel chains in the 32 threads, identifying the proper parent in a given thread requires a more sophisticated strategy involving the notion of block cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:96
#: d12b3df7273f4f3ebce83799c46a31ab
msgid "Block cliques"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:98
#: 9811286213f14f57abd1680acabc85b2
msgid "At any given time, the set of all the blocks that have been produced and propagated in the network constitutes a graph (more precisely a Directed Acyclic Graph or \"DAG\"), where each block, except the genesis blocks, has 32 parents. All the reasoning below can be in principle done on this increasingly vast set, but in practice, we will introduce a notion of \"finalized\" or \"staled\" blocks, that can be removed from the set and that will allow us to work on a smaller subset of recent blocks that are neither finalized nor staled, so \"pending\" blocks. This set of pending blocks is all the network needs to know in order to incrementally build up a consensus, therefore non-pending blocks will simply be forgotten (this is a striking difference with most other blockchains that store in each node the history of all past transactions). The main benefit of this block pruning is to allow for some of the algorithms below, which are in general NP-complete, to run fast enough on a smaller subgraph, and to allow for a practical implementation."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:108
#: 0fcc39f325df4a62a6bba114c1eb4768
msgid "Here is a simplified example of a graph of pending blocks over two threads, with blocks 3 and 4 competing for slot C1 (for example as a result of a multistaking attack where the block producer decided to create competing blocks for the same slot). Here the letter of a slot identifies it, while the number refers to its thread number:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:114
#: 11383672e71a41f28d6e5d99cad54a92
msgid "In this illustration we have shown only relevant parent links in blue, to make the whole diagram more readable, but in reality, each block has 32 parents, one in each of the 32 threads."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:117
#: 86d564256c8d4441a83e8c71ea6a5831
msgid "An important notion we will use in the following is that of incompatibility between blocks. Excluding some edge cases with genesis blocks, there are two sources of incompatibilities defined for blocks:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:120
#: 12170c2aa1ea49d1bdac7b3cce4e3c45
msgid "**thread incompatibility**: this occurs when two blocks in a given thread have the same parent in that thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:121
#: 75c6fb7bd83141929527634f89d889a3
msgid "**grandpa incompatibility**: this corresponds to a case with two blocks B1 and B2 in threads t1 and t2, and where the block B1 in t1 has a parent in t2 who is an ancestor of B2's parent in t2, and symmetrically B2's parent in t1 is an ancestor of B1's parent in t1."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:125
#: b71b5750bf644cbdb059ac835faa21e5
msgid "You will find a more formal mathematical definition of these incompatibility notions in the `whitepaper <https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:128
#: a0b983d8d224447885df5fe7ebfa8fb2
msgid "From these definitions, you can build another graph, called the incompatibility graph, which connects any two blocks that have any form of incompatibility together:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:133
#: a1bc84f33dbf4843956da5bf5623cc1f
msgid "As you can see, some blocks are isolated and therefore compatible with any other, while some are linked, because they have a form of incompatibility."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:136
#: 8e3d2678642d4cdf9d2501a165d9559d
msgid "This brings us to the notion of a maximal clique which is a subset of the incompatibility graph such as none of the block members are incompatible with each other (so, no internal link within the clique), and it is impossible to add an extra block to the set without introducing incompatibilities. In the above example, there are three maximal cliques that can be built, as illustrated below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:143
#: e82f84940e2149e590d8910854e3f930
msgid "They represent candidates to extend the set of already finalized blocks into a coherent set of new blocks. All we need to add to be able to build a consensus rule now is to introduce a deterministic metric to rank those candidates so that nodes can independently and consistently decide on which clique is the best candidate and keep building on top of it. In particular, once the best maximal clique is identified, it becomes trivial to define the list of the parents for a new block simply by picking the oldest block from that clique in each thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:149
#: 264aca9342994e6db6c88f04f1cd8ebc
msgid "The metric used in a traditional blockchain to rank competing chain candidates is habitually the length of the chain, or more precisely the total amount of work invested in the chain (also known as \"Nakamoto consensus\"). In the case of block cliques, we will introduce a notion of fitness for each block, and the fitness of the clique will simply be the sum of all its block's fitness. The block fitness :math:`f(b)` is simply defined as :math:`1+e`, :math:`e` being the number of endorsements registered in the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:155
#: 02cf4eb7c1824617a6cf21d400bf848f
msgid "Taking the maximal clique with the highest fitness (or some hash-based deterministic selection in case of equality), the Graph/Consensus module can define what is called the **blockclique** at the current time."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:159
#: 6fce481a15374d67a4fde96da8b0ab2f
msgid "Finalized blocks, stale blocks"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:161
#: 25a55cfa85114e40b6b00a81b41a9d49
msgid "The set of pending blocks is growing each time a new block is produced and added to the current set. As we mentioned previously, there is also a pruning mechanism in charge of reducing the size of the graph by removing blocks that are considered final, and also blocks that can be considered stale and will never finalize."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:165
#: 5271d00ef16646dfbb22823e3160f10e
msgid "If a block is only contained inside cliques that have a fitness lower than the fitness of the blockclique (the clique with the maximal fitness), minus a constant :math:`\\Delta_f^0`, then this block is considered stale. Also, any new block that includes in its parents a stale block is stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:169
#: 3b08468a5e7242bd9602594fd77d24e5
msgid "A block is considered final if it is part of all maximal cliques, and included in at least one clique where the total sum of the fitness of all its descendants is greater than :math:`\\Delta_f^0`."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:172
#: fb999632c0c14fc3a16f10ea2fbc3f7e
msgid ":math:`\\Delta_f^0` is defined as a constant :math:`F` multiplied by :math:`1+E` (:math:`E` being the total max number of endorsements in a block, currently 16), and :math:`F` effectively measuring the maximum span in fully endorsed blocks of a successful blockclique, or the number of fully endorsed blocks by which an alternative clique can be shorter than the blockclique before its blocks may be discarded as stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:178
#: 745f091d055a448ab952f1dd36c7d631
msgid "Graph/Consensus Module Function"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:180
#: 87434a1b58994e918f91b340528c5ed4
msgid "The Consensus Module (formerly known as the Graph) receives new block proposals, integrates them into the set of pending blocks, updating the blockclique with the method explained above, and verifying the legitimacy of the parenting of new blocks. It also informs other modules, like the Execution module, when blocks are finalized and the corresponding ledger modifications implied by their operations list should be made permanent."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:185
#: 10acbb5e46b44b0db919166f9c69ba36
msgid "It is also able to answer queries about the current best parents for a new block (based on the current blockclique) or the list of current maximal cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:189
#: b7e11b99354c4f19938b9b4b89b1b453
msgid "Execution Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:191
#: 0d69c0c1c0914054a5bc40ec378a7f41
msgid "The Execution Module is in charge of effectively executing the operations contained in blocks within the current blockclique, which is provided by the Graph/Consensus Module. Operations will typically modify the ledger, either by changing the balances of accounts or by modifying the datastore of smart contracts after the execution of some code. From an implementation point of view, ledger modifications are however stored as diff vs the current finalized ledger, until the corresponding blocks are marked as finalized by the Graph/Consensus Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:197
#: 7859850be5814286a77a47f342b1dcd3
msgid "Block creators will typically need to query the Execution Module to check current balances at a given slot and verify if some operations can be run with sufficient funds or not, before being integrated into a new block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:200
#: a9a5d178e05c4982b5affa732060c610
msgid "As a side note, it is also possible that blocks might include invalid operations, in which case the Execution Module will simply ignore them."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:203
#: 0517658c18ee4e0a85e2dfdf36c54646
msgid "Being the maintainer of the ledger, the Execution Module is also queried about address information in general, via the API, for any Module that needs it."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:206
#: 314443ee25f34833a13a0dd2583be884
msgid "Finally, the Execution Module will inform the Selector Module when new cycles are initiated as the finalization of blocks progresses."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:210
#: dc4ddaea87ed40c397ab60227a2fb618
msgid "Pool Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:212
#: 4d9b8f808b3e488581a86e1c8f53620c
msgid "When new pending operations reach a node, they are not immediately processed but instead are stored in a pool of pending operations, to be used by the Factory Module. Similarly, proposed endorsements coming from the Endorsement Factory are buffered inside the pool, to be integrated into new blocks by the Block Factory Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:216
#: 15f17cfacafc4f86a33899ae6ea27b9c
msgid "The origin of pending operations or endorsements inside the pool can be internal to the factory process or could come from remote nodes via the API Module. Similarly, locally produced pending endorsements are broadcasted via a gossip protocol to other pools via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:220
#: 074203d6bfa84993acb26cd94575f0bd
msgid "Note that operations stored in the Pool are naturally discarded after a certain time, since operations come with an expiration date in the `expiration_period` field. Still, some potential attacks can occur by trying to flood the pool with high fees operations that have no chance of being executed because the corresponding account does not have the required funds. Discussing about countermeasure for this is beyond the scope of this introduction."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:226
#: 0819e9a3c453469b9abeda961b3247d0
msgid "Block/Endorsement Factory Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:228
#: 677f44a254d443cbbb8068846c5c75f2
msgid "The Block Factory Module is in charge of creating new blocks when the corresponding node address has been designated to be the block creator for a given slot. This information is provided to the Factory Module from the Selector Module via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:232
#: 522d53b70c01490e977f60c320cc3fd4
msgid "The Block Factory Module also needs information about the best parents (made of the latest blocks in each thread in the blockclique) from the Graph/Consensus Module. These parents will be included in the newly created block. Balance information, in order to assess the validity of pending operations, is obtained from the Execution Module, which maintains the ledger state from the point of view of the slot where the new block is supposed to be created."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:237
#: 3ea5224576ad44ddacd011dc2bde6794
msgid "The Block Factory Module picks pending operations from the Pool Module. Note that the Block Factory will regularly query the Execution Module about finalized and executed operations, and internally cleanup operations that have been handled."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:240
#: d3770048fc204a1f8898f006504b29ba
msgid "Finally, the Block Factory will query the Pool Module and pick pending endorsements corresponding to the best parents that are selected for the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:243
#: 7f9edf4ca5fc442f8985fd54f518e59c
msgid "With this information, it is able to forge a new block that will then be propagated to the Graph/Consensus Module via the API Module, as well as to other nodes via gossip, to maintain a global synchronized state."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:246
#: cc8757c9f439402b9511e6d15910eac0
msgid "The Endorsement Factory Module works in a similar manner, requesting the Selector Module to find out when it has been designated to be an endorsement producer, then feeding new endorsements to the Pool Module and the API Module for global synchronization."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:251
#: b83a72fbefe2431f9fae7db272537fc5
msgid "Operation lifecycle"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:253
#: 7c39a3dfbf6b492a9a6e0f78f5c1bae5
msgid "We have now all the elements and vocabulary in place to explore the lifecycle of an operation within the network, from creation to permanent execution in a finalized block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:256
#: 340bd03330c749a7be447b7bd57253a8
msgid "Operations originate externally from a client that is forging the operation, for example: a transaction or a smart contract code execution. The client will have to know the IP address of a Massa Node (this can be either because it is a node itself and will simply use localhost, or via some maintained list of known nodes and/or some browser plugin), and will then send the operation to the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:261
#: 12f5440e729f41c2b9ff2e4ae56016d3
msgid "When an operation is made available in a given node, it will be broadcasted to all other nodes via the Protocol/Network Module and to factories via the API Module, so that it will eventually end up in all the Pool Modules of the network."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:264
#: 81b7c6e7bf814e849155ffe4d15103dd
msgid "Let's assume we just got a code execution operation from an external client. Let's suppose the client knows a particular node, which is running its block factory on the same machine, and sends the operation to this node. These are the different steps of the operation processing that will occur, as illustrated in the schema below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:268
#: 5a071f25f037428ab9f726bdd4ec1911
msgid "The operation enters the node via the API Module (the operation path is marked in blue)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:269
#: 8314e8f90e434700b02da902253dd4e7
msgid "The API Module forwards the operation to the Pool Module and broadcasts it to other nodes via the Protocol/Network Module. Other nodes hearing about it will also broadcast it (gossip protocol), and feed it to their Pool Module, unless they are pure consensus nodes without factories"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:272
#: a81b440ff9d54bc480580dc569e84b40
msgid "At that stage, the operation sits in the Pool Modules of most nodes"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:273
#: 758e6309dd7b4538ae0adcef19f3310d
msgid "The Selector Module elects a particular node to handle the block production of the next current slot"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:274
#: 96a7450026bb45ce88349447cda2c240
msgid "The elected node Block Factory finds out about its election by querying a Selector Module (via the API Module)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:275
#: 4afaff86a27e47b49b664b78c35ca0ad
msgid "It starts building a block by picking up pending operations in the Pool Module. The original operation is eventually picked and integrated into the block. We will now follow the block around (the block path is marked in green)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:277
#: 6e26dfabc3dd4a8f9c311aaa24323135
msgid "The newly produced block is sent via the API to remote or local nodes, to reach the Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:278
#: 6fac14ef59924a5ca7860afb4b081b15
msgid "The new block is processed by the Graph/Consensus Module to be included into the pending blocks DAG and potentially integrated into a new blockclique"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:280
#: a6da085142cc427fb0bb8fb8cc815b02
msgid "The Graph/Consensus Module sends the new block to other nodes via the Protocol/Network Module, to ensure synchronization of the information in the network. The new block reaching other nodes is similarly going to be integrated into their Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:283
#: 39b4445990af4e2abf95a96aa5b89ae8
msgid "In general, the blockclique will be extended with the new block and so will reach the Execution Module from the Graph/Consensus Module via the notification of a new blockclique. Eventually, it will also be notified as a final block if it gets finalized."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:286
#: faa75060db73474c8a80d5e8a79b79d3
msgid "The Execution Module will run the blocks that are part of the updated blockclique, so the original block will eventually be executed. Within the block is the original operation that was originally sent and that will then be applied to the ledger for potential modifications. At this stage, the modifications are not permanent and simply stored in a diff compared to the finalized ledger"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:290
#: 749a9223ee3a4aee9f0b1c2214e4d2ba
msgid "Eventually, the block will be marked as final and the ledger modification, including the operation changes, will become final in the finalized ledger."
msgstr ""
