# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Massa Labs
# This file is distributed under the same license as the Massa Localized Docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Massa Localized Docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-07-03 00:08+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../general-doc/architecture/archi-global.rst:2
#: 3161db2782b84b90aab63f5f1a753ebc
msgid "Architecture"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:4
#: ccd0c2c07e3b42179a0f16479ce6bd9c
msgid "This is the diagram of the architecture of the software modules involved in building, endorsing and propagating blocks. The bottom part corresponds to a single process running in a node and is in charge of the execution and consensus building. The pool and factories, referred to as \"factory\", can be potentially running in a different process or be part of the node. Overall, each of the modules described here runs inside one or more threads attached to their respective executable process (NB: the factory/node separation is not yet implemented, but will be soon)."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:12
#: d6ccb71442e64899984a75d0989939f4
msgid "We will explain below the different modules present in this diagram, and simulate the production of an operation to show how it navigates through the different modules to better understand how blocks are produced and propagated."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:16
#: 37e4a58d097a40c4b0f616cfacbcbfc3
msgid "Bootstrap Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:18
#: 8dbc43f98d894179bc64b2af238a5a9a
msgid "The bootstrap module is responsible for the initial synchronization of the node with the rest of the network. It is responsible for downloading the list of peers, the current graph of blocks, the ledger, the asynchronous pool, state of the Proof-of-Stake and latests executed operations."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:22
#: 0d3b8981ae8b40558754ccf6052ff08a
msgid "The bootstrap will be done from a server that is listed on the configuration of the node. Bootstrap is the entry point of the network so you have to be careful on which node you connect to avoid downloading malicious data."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:26
#: d56b7fc383684d288e9b7c6a64d92963
msgid "API Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:28
#: 0b3aaa5e74e34a849850fa8c54e4b03b
msgid "The API Module is the public window of the node to the rest of the world. It allows for interactions with external clients or factories via a JSON RPC protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:31
#: 741fddba94fa4b74b50f7c491cc5246f
msgid "The API includes interfaces to do the following:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:33
#: 842c8076d04149689f8b7bb84c33a5fc
msgid "publish a new operation from a client"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:34
#: caab9eed1f1b4921ad40b4b57109a3e9
msgid "query the network about balances or ledger status"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:35
#: 4a78ae4c48e940738ff43dd018145589
msgid "allow for synchronization between remote pool/factory nodes and the consensus nodes, by sending/asking for blocks, best parents, draws, etc."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:39
#: b21998316a40460dbc52d0ae8f8ee23d
msgid "Protocol/Network Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:41
#: faefa8361b9e4ae88dd320e0f3062c1d
msgid "The Protocol/Network Module implements the protocol connecting consensus nodes. This protocol is supported by a binary and optimized transport layer and does not use JSON RPC."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:44
#: c8fbf904fe554ca4b6e4d8161aefac77
msgid "The Protocol/Network Module will relay all operations/blocks creation and propagation, so that all other nodes in the network can synchronize their internal state, following a type of gossip synchronization protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:47
#: 2c4ec25ed30e47e182616002012d3a04
msgid "The type of messages that can be relayed via the Protocol/Network Module include:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:49
#: 50d4ac3f11aa415f9f0c3453b271a72c
msgid "blocks/operations/endorsements propagation (either getting in or out of the node)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:50
#: 841c586b4ed74b3787681769d25f89ea
msgid "nodes ban requests"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:51
#: 193b117199c54e0285059c6fb4ba6dec
msgid "connectivity infos/stats"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:54
#: c4eac8e80fcd4bf7b526f8fc157fcbb2
msgid "Selector Module, Proof of Stake sybil resistance"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:56
#: 49451bebab604f6d93d6d9b58d09e9db
msgid "Every 0.5s, a new slot becomes active to receive a new block. A determinist selection mechanism ensures that one of the nodes in the network is elected to have the responsibility to build the block for that slot. This mechanism must have several key properties:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:60
#: 71e37c59e3a64fd0967ed0aee511c177
msgid "it should be sybil resistant, so that it is not possible to increase one's odds of being elected by creating multiple clones of oneself (sybil) without a cost that is equal or greater than the cost of increasing one's odds for oneself only"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:63
#: 1e6d9d4d683c400783109aa5553e6740
msgid "it should be deterministic, so that all nodes in the network will agree on the result of the selection at any given time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:65
#: 5c699ceff9974968b1f72e0b55e1bbb0
msgid "it should be fair, so that each participant has a well-defined probability of being selected somehow proportional to the cost of participating, and draws converge towards this probability distribution over time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:68
#: ac4701bba37a4c30bae27ce1a78d1743
msgid "The way sybil resistance is achieved here is via the proof of stake mechanism. Nodes who want to participate in the block creation lottery will have to stake \"rolls\" that they buy with Massa coins. If they try to cheat by creating fake blocks or multiple blocks on the same slot, their stake will be taken away from them (slashing) and they would suffer the loss. The probabilistic \"surface\" of a participant is equal to its total stake, which makes the creation of sybil accounts useless because the stake would have to be split between them anyway."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:74
#: 05498914d7c54e9987b023313504962e
msgid "The method used to draw an elected node for a given slot is simply a random draw from a distribution where addresses are weighted by the amount of stake (=rolls) they hold. The schema below illustrates how the seed and probability distribution are built, based on past cycles (two cycles are needed for the distribution update to ensure that the balance finalization has occurred and the amount of rolls is accurate):"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:81
#: 01ea201aec8b40708eb0913ba95c1abc
msgid "The Selector Module is in charge of computing the formula and replying to requests regarding what node is elected for any given slot in the present or the past. The Execution Module (see below) is in charge of feeding the Selector Module with updates regarding balances, needed to compute the draws."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:86
#: 8260a09f39ca4503a2f0dba9ab7b2a18
msgid "Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:88
#: 8daaa5f2132e44eeb5ff997d9afa05d6
msgid "The Consensus Module is the heart of the machinery of the Massa Network. It is in charge of integrating proposed blocks into their respective slots and verifying the integrity of the result. We have not yet talked about the various constraints regarding block creation, and in particular how parents are to be selected. In traditional blockchains, the parent of a block is simply the previous valid block in the chain. In the context of the Massa network and the parallel chains in the 32 threads, identifying the proper parent in a given thread requires a more sophisticated strategy involving the notion of block cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:96
#: 111be46560ad4d19a8e5298459301b62
msgid "Block cliques"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:98
#: b292bb5c187c47f192278f36e5fb135a
msgid "At any given time, the set of all the blocks that have been produced and propagated in the network constitutes a graph (more precisely a Directed Acyclic Graph or \"DAG\"), where each block, except the genesis blocks, has 32 parents. All the reasoning below can be in principle done on this increasingly vast set, but in practice, we will introduce a notion of \"finalized\" or \"staled\" blocks, that can be removed from the set and that will allow us to work on a smaller subset of recent blocks that are neither finalized nor staled, so \"pending\" blocks. This set of pending blocks is all the network needs to know in order to incrementally build up a consensus, therefore non-pending blocks will simply be forgotten (this is a striking difference with most other blockchains that store in each node the history of all past transactions). The main benefit of this block pruning is to allow for some of the algorithms below, which are in general NP-complete, to run fast enough on a smaller subgraph, and to allow for a practical implementation."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:108
#: 10b0ded331db4dd9bf3cf9b9a7a1a599
msgid "Here is a simplified example of a graph of pending blocks over two threads, with blocks 3 and 4 competing for slot C1 (for example as a result of a multistaking attack where the block producer decided to create competing blocks for the same slot). Here the letter of a slot identifies it, while the number refers to its thread number:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:114
#: ffa70a5b2cfa40279e57aae265e5eac1
msgid "In this illustration we have shown only relevant parent links in blue, to make the whole diagram more readable, but in reality, each block has 32 parents, one in each of the 32 threads."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:117
#: 3a78750b26114f52a441e463473b46de
msgid "An important notion we will use in the following is that of incompatibility between blocks. Excluding some edge cases with genesis blocks, there are two sources of incompatibilities defined for blocks:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:120
#: 899b1d449919407098182c0520c65fea
msgid "**thread incompatibility**: this occurs when two blocks in a given thread have the same parent in that thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:121
#: d877f7ef29f84865881310dc942e71d5
msgid "**grandpa incompatibility**: this corresponds to a case with two blocks B1 and B2 in threads t1 and t2, and where the block B1 in t1 has a parent in t2 who is an ancestor of B2's parent in t2, and symmetrically B2's parent in t1 is an ancestor of B1's parent in t1."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:125
#: c7b13e8f2a40431dbce1d8509cadb8bb
msgid "You will find a more formal mathematical definition of these incompatibility notions in the `whitepaper <https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:128
#: c30ae78cb7104b098b92cf6fc89df830
msgid "From these definitions, you can build another graph, called the incompatibility graph, which connects any two blocks that have any form of incompatibility together:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:133
#: 8092afda1c404f509de9e44b43d10acb
msgid "As you can see, some blocks are isolated and therefore compatible with any other, while some are linked, because they have a form of incompatibility."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:136
#: a46734afc851432580985e53e9a35fb8
msgid "This brings us to the notion of a maximal clique which is a subset of the incompatibility graph such as none of the block members are incompatible with each other (so, no internal link within the clique), and it is impossible to add an extra block to the set without introducing incompatibilities. In the above example, there are three maximal cliques that can be built, as illustrated below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:143
#: 581350fd69a4449b8177c5066e437188
msgid "They represent candidates to extend the set of already finalized blocks into a coherent set of new blocks. All we need to add to be able to build a consensus rule now is to introduce a deterministic metric to rank those candidates so that nodes can independently and consistently decide on which clique is the best candidate and keep building on top of it. In particular, once the best maximal clique is identified, it becomes trivial to define the list of the parents for a new block simply by picking the oldest block from that clique in each thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:149
#: 994cfc625d5e4528832637707db2d25e
msgid "The metric used in a traditional blockchain to rank competing chain candidates is habitually the length of the chain, or more precisely the total amount of work invested in the chain (also known as \"Nakamoto consensus\"). In the case of block cliques, we will introduce a notion of fitness for each block, and the fitness of the clique will simply be the sum of all its block's fitness. The block fitness :math:`f(b)` is simply defined as :math:`1+e`, :math:`e` being the number of endorsements registered in the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:155
#: 52baf992317e416a9f0511587a5693c5
msgid "Taking the maximal clique with the highest fitness (or some hash-based deterministic selection in case of equality), the Graph/Consensus module can define what is called the **blockclique** at the current time."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:159
#: 2225eb280221450ea35fe48ad5924c45
msgid "Finalized blocks, stale blocks"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:161
#: 1570a208771f4e7c89c9627add8364ca
msgid "The set of pending blocks is growing each time a new block is produced and added to the current set. As we mentioned previously, there is also a pruning mechanism in charge of reducing the size of the graph by removing blocks that are considered final, and also blocks that can be considered stale and will never finalize."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:165
#: 4ef066d9bc844918957c1e6c634c2236
msgid "If a block is only contained inside cliques that have a fitness lower than the fitness of the blockclique (the clique with the maximal fitness), minus a constant :math:`\\Delta_f^0`, then this block is considered stale. Also, any new block that includes in its parents a stale block is stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:169
#: a15e5a77dd484a7b9794a1472dfb76f4
msgid "A block is considered final if it is part of all maximal cliques, and included in at least one clique where the total sum of the fitness of all its descendants is greater than :math:`\\Delta_f^0`."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:172
#: 9d5b2991a9c34bcb8de7791a4e70aeff
msgid ":math:`\\Delta_f^0` is defined as a constant :math:`F` multiplied by :math:`1+E` (:math:`E` being the total max number of endorsements in a block, currently 16), and :math:`F` effectively measuring the maximum span in fully endorsed blocks of a successful blockclique, or the number of fully endorsed blocks by which an alternative clique can be shorter than the blockclique before its blocks may be discarded as stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:178
#: b68c74f76e2a4907a606de628e9be24c
msgid "Graph/Consensus Module Function"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:180
#: ac662113e98b4db4811e4e108c3c9105
msgid "The Consensus Module (formerly known as the Graph) receives new block proposals, integrates them into the set of pending blocks, updating the blockclique with the method explained above, and verifying the legitimacy of the parenting of new blocks. It also informs other modules, like the Execution module, when blocks are finalized and the corresponding ledger modifications implied by their operations list should be made permanent."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:185
#: 514abb6a425f4fdd8d42125b64817a7e
msgid "It is also able to answer queries about the current best parents for a new block (based on the current blockclique) or the list of current maximal cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:189
#: 44d6232783fc498ba0281b73331914ac
msgid "Execution Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:191
#: 2dca5116de5f4522a07d023c71d8e4a7
msgid "The Execution Module is in charge of effectively executing the operations contained in blocks within the current blockclique, which is provided by the Graph/Consensus Module. Operations will typically modify the ledger, either by changing the balances of accounts or by modifying the datastore of smart contracts after the execution of some code. From an implementation point of view, ledger modifications are however stored as diff vs the current finalized ledger, until the corresponding blocks are marked as finalized by the Graph/Consensus Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:197
#: bb86389625bf47db9a7aab7923e64c27
msgid "Block creators will typically need to query the Execution Module to check current balances at a given slot and verify if some operations can be run with sufficient funds or not, before being integrated into a new block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:200
#: 6b29592e3a8b4f18b1432329a67ab4ce
msgid "As a side note, it is also possible that blocks might include invalid operations, in which case the Execution Module will simply ignore them."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:203
#: 47499cd4c5c84985832b3d85de153a52
msgid "Being the maintainer of the ledger, the Execution Module is also queried about address information in general, via the API, for any Module that needs it."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:206
#: 2857f83283974e0cbffc0e89ee560855
msgid "Finally, the Execution Module will inform the Selector Module when new cycles are initiated as the finalization of blocks progresses."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:210
#: 73952050e5704442b3e38a99fc032206
msgid "Pool Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:212
#: e1c7e9878fb14d2bb10b2e6738ebb874
msgid "When new pending operations reach a node, they are not immediately processed but instead are stored in a pool of pending operations, to be used by the Factory Module. Similarly, proposed endorsements coming from the Endorsement Factory are buffered inside the pool, to be integrated into new blocks by the Block Factory Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:216
#: 456e61ee9e7447d2b171d839d5477b91
msgid "The origin of pending operations or endorsements inside the pool can be internal to the factory process or could come from remote nodes via the API Module. Similarly, locally produced pending endorsements are broadcasted via a gossip protocol to other pools via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:220
#: 5deb7e7df0c7429eb409b0d97d92501f
msgid "Note that operations stored in the Pool are naturally discarded after a certain time, since operations come with an expiration date in the `expiration_period` field. Still, some potential attacks can occur by trying to flood the pool with high fees operations that have no chance of being executed because the corresponding account does not have the required funds. Discussing about countermeasure for this is beyond the scope of this introduction."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:226
#: 0a7da487e7b74a168eadf86c4af130b5
msgid "Block/Endorsement Factory Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:228
#: e0848a0982694802a1a416aefd9cf7f6
msgid "The Block Factory Module is in charge of creating new blocks when the corresponding node address has been designated to be the block creator for a given slot. This information is provided to the Factory Module from the Selector Module via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:232
#: e1a3d8673ba044cf9c73fe42df3d5214
msgid "The Block Factory Module also needs information about the best parents (made of the latest blocks in each thread in the blockclique) from the Graph/Consensus Module. These parents will be included in the newly created block. Balance information, in order to assess the validity of pending operations, is obtained from the Execution Module, which maintains the ledger state from the point of view of the slot where the new block is supposed to be created."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:237
#: dcd54a267871458b989ea421b01c7855
msgid "The Block Factory Module picks pending operations from the Pool Module. Note that the Block Factory will regularly query the Execution Module about finalized and executed operations, and internally cleanup operations that have been handled."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:240
#: e085f023bba14aa9bd47eb76a0e9ee69
msgid "Finally, the Block Factory will query the Pool Module and pick pending endorsements corresponding to the best parents that are selected for the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:243
#: 1aa0fbe789f1400eab8a2bcde4dd8847
msgid "With this information, it is able to forge a new block that will then be propagated to the Graph/Consensus Module via the API Module, as well as to other nodes via gossip, to maintain a global synchronized state."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:246
#: c02b3c07e1e04ebca4f9ac6d220e1b21
msgid "The Endorsement Factory Module works in a similar manner, requesting the Selector Module to find out when it has been designated to be an endorsement producer, then feeding new endorsements to the Pool Module and the API Module for global synchronization."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:251
#: 6b9d6f11ed6c4e29a477590873011284
msgid "Operation lifecycle"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:253
#: ca2dff2560ca419aacdc85a29244fb61
msgid "We have now all the elements and vocabulary in place to explore the lifecycle of an operation within the network, from creation to permanent execution in a finalized block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:256
#: f1530e45e4ae49eeac6ecb06e21b6c52
msgid "Operations originate externally from a client that is forging the operation, for example: a transaction or a smart contract code execution. The client will have to know the IP address of a Massa Node (this can be either because it is a node itself and will simply use localhost, or via some maintained list of known nodes and/or some browser plugin), and will then send the operation to the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:261
#: ee956e956fb947a6b81d3445a769de12
msgid "When an operation is made available in a given node, it will be broadcasted to all other nodes via the Protocol/Network Module and to factories via the API Module, so that it will eventually end up in all the Pool Modules of the network."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:264
#: 9b02c4ef16eb4edca2c95cffeb270717
msgid "Let's assume we just got a code execution operation from an external client. Let's suppose the client knows a particular node, which is running its block factory on the same machine, and sends the operation to this node. These are the different steps of the operation processing that will occur, as illustrated in the schema below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:268
#: 7c6ffbf3c6cc4a1e97054a0bb3d15229
msgid "The operation enters the node via the API Module (the operation path is marked in blue)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:269
#: af9307c511d44fc3b34660799b7724ba
msgid "The API Module forwards the operation to the Pool Module and broadcasts it to other nodes via the Protocol/Network Module. Other nodes hearing about it will also broadcast it (gossip protocol), and feed it to their Pool Module, unless they are pure consensus nodes without factories"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:272
#: 14457925e67846d69a0ef728c69d4736
msgid "At that stage, the operation sits in the Pool Modules of most nodes"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:273
#: d4296e051eeb425680c5da9caeb5da53
msgid "The Selector Module elects a particular node to handle the block production of the next current slot"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:274
#: 3adc576d49d1439c9ee0f85434ef59de
msgid "The elected node Block Factory finds out about its election by querying a Selector Module (via the API Module)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:275
#: 030b717018914579aeee98e89433e25e
msgid "It starts building a block by picking up pending operations in the Pool Module. The original operation is eventually picked and integrated into the block. We will now follow the block around (the block path is marked in green)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:277
#: a4405571fce74b8280564a1e94f2a7f7
msgid "The newly produced block is sent via the API to remote or local nodes, to reach the Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:278
#: ba40129bc18c4625bdfc1c613c52c464
msgid "The new block is processed by the Graph/Consensus Module to be included into the pending blocks DAG and potentially integrated into a new blockclique"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:280
#: 9936e7a6d20d4f79b255b4ba8aabad19
msgid "The Graph/Consensus Module sends the new block to other nodes via the Protocol/Network Module, to ensure synchronization of the information in the network. The new block reaching other nodes is similarly going to be integrated into their Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:283
#: 5e718eeda44845d98036689c49e58e27
msgid "In general, the blockclique will be extended with the new block and so will reach the Execution Module from the Graph/Consensus Module via the notification of a new blockclique. Eventually, it will also be notified as a final block if it gets finalized."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:286
#: 24ad0e5be7044740a2ea7ad8544c4240
msgid "The Execution Module will run the blocks that are part of the updated blockclique, so the original block will eventually be executed. Within the block is the original operation that was originally sent and that will then be applied to the ledger for potential modifications. At this stage, the modifications are not permanent and simply stored in a diff compared to the finalized ledger"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:290
#: 4d133fd55c6847aa8b1c4d013a1308cf
msgid "Eventually, the block will be marked as final and the ledger modification, including the operation changes, will become final in the finalized ledger."
msgstr ""
