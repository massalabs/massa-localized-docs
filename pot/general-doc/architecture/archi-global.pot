# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Massa Labs
# This file is distributed under the same license as the Massa Localized Docs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Massa Localized Docs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-06-15 00:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../general-doc/architecture/archi-global.rst:2
#: a9ae2b65676d48c1a64b18c007683b5d
msgid "Architecture"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:4
#: f445d823e19c4150b54d81f960c7c772
msgid "This is the diagram of the architecture of the software modules involved in building, endorsing and propagating blocks. The bottom part corresponds to a single process running in a node and is in charge of the execution and consensus building. The pool and factories, referred to as \"factory\", can be potentially running in a different process or be part of the node. Overall, each of the modules described here runs inside one or more threads attached to their respective executable process (NB: the factory/node separation is not yet implemented, but will be soon)."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:12
#: 8bbc51fe92324175a817db4501224df8
msgid "We will explain below the different modules present in this diagram, and simulate the production of an operation to show how it navigates through the different modules to better understand how blocks are produced and propagated."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:16
#: 26ccb25761194739b9940896d9e9646f
msgid "Bootstrap Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:18
#: b028a0387ee84155b6d1de95e3ef732a
msgid "The bootstrap module is responsible for the initial synchronization of the node with the rest of the network. It is responsible for downloading the list of peers, the current graph of blocks, the ledger, the asynchronous pool, state of the Proof-of-Stake and latests executed operations."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:22
#: aa5959918e8844e4bb16f85fc4552a7c
msgid "The bootstrap will be done from a server that is listed on the configuration of the node. Bootstrap is the entry point of the network so you have to be careful on which node you connect to avoid downloading malicious data."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:26
#: 1865cdcaf90b4bb698919e444b9b7849
msgid "API Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:28
#: abd17966b423489082b74dab957cd2e4
msgid "The API Module is the public window of the node to the rest of the world. It allows for interactions with external clients or factories via a JSON RPC protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:31
#: 771ee43236834f4db304ad9c73ba5ff6
msgid "The API includes interfaces to do the following:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:33
#: 921d51517ccb45358f04436f55b7fdc1
msgid "publish a new operation from a client"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:34
#: c862a83de7b24d20b15342f2fb25f4cc
msgid "query the network about balances or ledger status"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:35
#: 185f6053568e42e2a6ad055935032da6
msgid "allow for synchronization between remote pool/factory nodes and the consensus nodes, by sending/asking for blocks, best parents, draws, etc."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:39
#: 7c7474a1ac2543388190e54588720696
msgid "Protocol/Network Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:41
#: 8cb2add0b4804bd9a50a85741d2101a0
msgid "The Protocol/Network Module implements the protocol connecting consensus nodes. This protocol is supported by a binary and optimized transport layer and does not use JSON RPC."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:44
#: d98cf77f624e48f6a48de44ad192d6a1
msgid "The Protocol/Network Module will relay all operations/blocks creation and propagation, so that all other nodes in the network can synchronize their internal state, following a type of gossip synchronization protocol."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:47
#: 6fc9192d8a2b4efc9db8d898a5de5eed
msgid "The type of messages that can be relayed via the Protocol/Network Module include:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:49
#: e1d4b4e4a2444c49b98c77f9aee71e8b
msgid "blocks/operations/endorsements propagation (either getting in or out of the node)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:50
#: e7a3849d7da34e7a98fa3ff7d39c0044
msgid "nodes ban requests"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:51
#: dc9dd5591e3f4b098393c8e356f065a9
msgid "connectivity infos/stats"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:54
#: 4fc5ed4753514c1eb6ef7d0866461103
msgid "Selector Module, Proof of Stake sybil resistance"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:56
#: 9b63e421ae4f4b698a70e40cda3c97a4
msgid "Every 0.5s, a new slot becomes active to receive a new block. A determinist selection mechanism ensures that one of the nodes in the network is elected to have the responsibility to build the block for that slot. This mechanism must have several key properties:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:60
#: 8e00267d12524d06bb29277c8ddc52ea
msgid "it should be sybil resistant, so that it is not possible to increase one's odds of being elected by creating multiple clones of oneself (sybil) without a cost that is equal or greater than the cost of increasing one's odds for oneself only"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:63
#: 7b37f8589d934b3ab5bbbd9003061142
msgid "it should be deterministic, so that all nodes in the network will agree on the result of the selection at any given time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:65
#: 4be0b7e6a2fc4d56bdc4b02c1b1fb59d
msgid "it should be fair, so that each participant has a well-defined probability of being selected somehow proportional to the cost of participating, and draws converge towards this probability distribution over time"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:68
#: 20b39f1769594795b9539fa4e5704acd
msgid "The way sybil resistance is achieved here is via the proof of stake mechanism. Nodes who want to participate in the block creation lottery will have to stake \"rolls\" that they buy with Massa coins. If they try to cheat by creating fake blocks or multiple blocks on the same slot, their stake will be taken away from them (slashing) and they would suffer the loss. The probabilistic \"surface\" of a participant is equal to its total stake, which makes the creation of sybil accounts useless because the stake would have to be split between them anyway."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:74
#: 7b89c645141142b3a9ee3037baa13080
msgid "The method used to draw an elected node for a given slot is simply a random draw from a distribution where addresses are weighted by the amount of stake (=rolls) they hold. The schema below illustrates how the seed and probability distribution are built, based on past cycles (two cycles are needed for the distribution update to ensure that the balance finalization has occurred and the amount of rolls is accurate):"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:81
#: 1646e775a01f4febb62dafd149c82291
msgid "The Selector Module is in charge of computing the formula and replying to requests regarding what node is elected for any given slot in the present or the past. The Execution Module (see below) is in charge of feeding the Selector Module with updates regarding balances, needed to compute the draws."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:86
#: 1ea93e536be444f8a93e67f49b3ca606
msgid "Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:88
#: 07745d0ae0d2435db878c1f8ae9f3a32
msgid "The Consensus Module is the heart of the machinery of the Massa Network. It is in charge of integrating proposed blocks into their respective slots and verifying the integrity of the result. We have not yet talked about the various constraints regarding block creation, and in particular how parents are to be selected. In traditional blockchains, the parent of a block is simply the previous valid block in the chain. In the context of the Massa network and the parallel chains in the 32 threads, identifying the proper parent in a given thread requires a more sophisticated strategy involving the notion of block cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:96
#: 52d3818cbcef471f96d5a7850bf3d128
msgid "Block cliques"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:98
#: 8f17c0a45f3f48889fc2ac6a32a52af4
msgid "At any given time, the set of all the blocks that have been produced and propagated in the network constitutes a graph (more precisely a Directed Acyclic Graph or \"DAG\"), where each block, except the genesis blocks, has 32 parents. All the reasoning below can be in principle done on this increasingly vast set, but in practice, we will introduce a notion of \"finalized\" or \"staled\" blocks, that can be removed from the set and that will allow us to work on a smaller subset of recent blocks that are neither finalized nor staled, so \"pending\" blocks. This set of pending blocks is all the network needs to know in order to incrementally build up a consensus, therefore non-pending blocks will simply be forgotten (this is a striking difference with most other blockchains that store in each node the history of all past transactions). The main benefit of this block pruning is to allow for some of the algorithms below, which are in general NP-complete, to run fast enough on a smaller subgraph, and to allow for a practical implementation."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:108
#: 2ee85ab4733c41cead47789ec59e4572
msgid "Here is a simplified example of a graph of pending blocks over two threads, with blocks 3 and 4 competing for slot C1 (for example as a result of a multistaking attack where the block producer decided to create competing blocks for the same slot). Here the letter of a slot identifies it, while the number refers to its thread number:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:114
#: 2f333aa32eeb4d999ad6dd77721f799a
msgid "In this illustration we have shown only relevant parent links in blue, to make the whole diagram more readable, but in reality, each block has 32 parents, one in each of the 32 threads."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:117
#: 1c378472bb914aef9c80a0c2501dc51b
msgid "An important notion we will use in the following is that of incompatibility between blocks. Excluding some edge cases with genesis blocks, there are two sources of incompatibilities defined for blocks:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:120
#: 8dc2f78ca9eb4829b9eb4b3fa13c1931
msgid "**thread incompatibility**: this occurs when two blocks in a given thread have the same parent in that thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:121
#: 8fab4786ae584f4c8626b3213a78e3e7
msgid "**grandpa incompatibility**: this corresponds to a case with two blocks B1 and B2 in threads t1 and t2, and where the block B1 in t1 has a parent in t2 who is an ancestor of B2's parent in t2, and symmetrically B2's parent in t1 is an ancestor of B1's parent in t1."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:125
#: 7438de6bdf744811b211cc568a455a4d
msgid "You will find a more formal mathematical definition of these incompatibility notions in the `whitepaper <https://arxiv.org/pdf/1803.09029.pdf>`_."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:128
#: 71cf54e3f2744d2d92cade8a78911d9c
msgid "From these definitions, you can build another graph, called the incompatibility graph, which connects any two blocks that have any form of incompatibility together:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:133
#: d4370f0ef55e41e2ba3307fc96cd2c87
msgid "As you can see, some blocks are isolated and therefore compatible with any other, while some are linked, because they have a form of incompatibility."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:136
#: 4cf13b845c864a96b3b18696adc8b1d7
msgid "This brings us to the notion of a maximal clique which is a subset of the incompatibility graph such as none of the block members are incompatible with each other (so, no internal link within the clique), and it is impossible to add an extra block to the set without introducing incompatibilities. In the above example, there are three maximal cliques that can be built, as illustrated below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:143
#: 66600baaef0f4bf283e40dd889552a29
msgid "They represent candidates to extend the set of already finalized blocks into a coherent set of new blocks. All we need to add to be able to build a consensus rule now is to introduce a deterministic metric to rank those candidates so that nodes can independently and consistently decide on which clique is the best candidate and keep building on top of it. In particular, once the best maximal clique is identified, it becomes trivial to define the list of the parents for a new block simply by picking the oldest block from that clique in each thread."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:149
#: d741454deb5f4ef592e360aa57c04b30
msgid "The metric used in a traditional blockchain to rank competing chain candidates is habitually the length of the chain, or more precisely the total amount of work invested in the chain (also known as \"Nakamoto consensus\"). In the case of block cliques, we will introduce a notion of fitness for each block, and the fitness of the clique will simply be the sum of all its block's fitness. The block fitness :math:`f(b)` is simply defined as :math:`1+e`, :math:`e` being the number of endorsements registered in the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:155
#: 2989138853db4faf9e005e211e640b3b
msgid "Taking the maximal clique with the highest fitness (or some hash-based deterministic selection in case of equality), the Graph/Consensus module can define what is called the **blockclique** at the current time."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:159
#: 52c74f5740264dfe8fcbb4a479b102fc
msgid "Finalized blocks, stale blocks"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:161
#: 0d84bc8377b048ddacea06704dc2ab62
msgid "The set of pending blocks is growing each time a new block is produced and added to the current set. As we mentioned previously, there is also a pruning mechanism in charge of reducing the size of the graph by removing blocks that are considered final, and also blocks that can be considered stale and will never finalize."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:165
#: 87d26bbbfc3d49e5bd910af805704b12
msgid "If a block is only contained inside cliques that have a fitness lower than the fitness of the blockclique (the clique with the maximal fitness), minus a constant :math:`\\Delta_f^0`, then this block is considered stale. Also, any new block that includes in its parents a stale block is stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:169
#: bb9f056044f24552914bd725232c5dbf
msgid "A block is considered final if it is part of all maximal cliques, and included in at least one clique where the total sum of the fitness of all its descendants is greater than :math:`\\Delta_f^0`."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:172
#: 10728d704b0d4c4cb2a3594ed4de1397
msgid ":math:`\\Delta_f^0` is defined as a constant :math:`F` multiplied by :math:`1+E` (:math:`E` being the total max number of endorsements in a block, currently 16), and :math:`F` effectively measuring the maximum span in fully endorsed blocks of a successful blockclique, or the number of fully endorsed blocks by which an alternative clique can be shorter than the blockclique before its blocks may be discarded as stale."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:178
#: 3277ea6228ec4e80938a01f907bda58c
msgid "Graph/Consensus Module Function"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:180
#: 9a7507d9b0c243c080a2ece1b464a2d7
msgid "The Consensus Module (formerly known as the Graph) receives new block proposals, integrates them into the set of pending blocks, updating the blockclique with the method explained above, and verifying the legitimacy of the parenting of new blocks. It also informs other modules, like the Execution module, when blocks are finalized and the corresponding ledger modifications implied by their operations list should be made permanent."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:185
#: bedad6d91ea44985b9ad19ca3d2254d0
msgid "It is also able to answer queries about the current best parents for a new block (based on the current blockclique) or the list of current maximal cliques."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:189
#: f517b47e812b4210a41bf0f20ced6a5f
msgid "Execution Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:191
#: 18b7021430b74554a9ea93657dcefaf8
msgid "The Execution Module is in charge of effectively executing the operations contained in blocks within the current blockclique, which is provided by the Graph/Consensus Module. Operations will typically modify the ledger, either by changing the balances of accounts or by modifying the datastore of smart contracts after the execution of some code. From an implementation point of view, ledger modifications are however stored as diff vs the current finalized ledger, until the corresponding blocks are marked as finalized by the Graph/Consensus Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:197
#: 8267ea0d381e4e259b915c14f4d6f221
msgid "Block creators will typically need to query the Execution Module to check current balances at a given slot and verify if some operations can be run with sufficient funds or not, before being integrated into a new block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:200
#: 5d8931089ffe42b7b77f7b206ed2a0ca
msgid "As a side note, it is also possible that blocks might include invalid operations, in which case the Execution Module will simply ignore them."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:203
#: 33823b9b40c24aadbab54a51188b717a
msgid "Being the maintainer of the ledger, the Execution Module is also queried about address information in general, via the API, for any Module that needs it."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:206
#: 05e1cc3050af4739875d4bf76e979a3d
msgid "Finally, the Execution Module will inform the Selector Module when new cycles are initiated as the finalization of blocks progresses."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:210
#: ebee2c4efd3c4a839c4e82400e754f03
msgid "Pool Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:212
#: 76d9fa4e4ac942d9b45148159d81486d
msgid "When new pending operations reach a node, they are not immediately processed but instead are stored in a pool of pending operations, to be used by the Factory Module. Similarly, proposed endorsements coming from the Endorsement Factory are buffered inside the pool, to be integrated into new blocks by the Block Factory Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:216
#: 43560fe706c340dc8a6abc033dca3faa
msgid "The origin of pending operations or endorsements inside the pool can be internal to the factory process or could come from remote nodes via the API Module. Similarly, locally produced pending endorsements are broadcasted via a gossip protocol to other pools via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:220
#: d77b4988f0d2411ba1b3a1d9ceccf57b
msgid "Note that operations stored in the Pool are naturally discarded after a certain time, since operations come with an expiration date in the `expiration_period` field. Still, some potential attacks can occur by trying to flood the pool with high fees operations that have no chance of being executed because the corresponding account does not have the required funds. Discussing about countermeasure for this is beyond the scope of this introduction."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:226
#: 64b8351a82b0438d8e8821e42c5c64b3
msgid "Block/Endorsement Factory Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:228
#: 222b47a670b5436c99413fa8755f88cb
msgid "The Block Factory Module is in charge of creating new blocks when the corresponding node address has been designated to be the block creator for a given slot. This information is provided to the Factory Module from the Selector Module via the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:232
#: 39628dd6d3744827a71e750a0cfbdf36
msgid "The Block Factory Module also needs information about the best parents (made of the latest blocks in each thread in the blockclique) from the Graph/Consensus Module. These parents will be included in the newly created block. Balance information, in order to assess the validity of pending operations, is obtained from the Execution Module, which maintains the ledger state from the point of view of the slot where the new block is supposed to be created."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:237
#: 2646ebdd9f474fb8b9a12f54caae01c7
msgid "The Block Factory Module picks pending operations from the Pool Module. Note that the Block Factory will regularly query the Execution Module about finalized and executed operations, and internally cleanup operations that have been handled."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:240
#: 0c2bb2af81744a7eb5a072b5b6a0f042
msgid "Finally, the Block Factory will query the Pool Module and pick pending endorsements corresponding to the best parents that are selected for the block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:243
#: 44925d060aa64149bcad0a8fe649b58b
msgid "With this information, it is able to forge a new block that will then be propagated to the Graph/Consensus Module via the API Module, as well as to other nodes via gossip, to maintain a global synchronized state."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:246
#: 26b93a884aa841dea5d2ad655e65309a
msgid "The Endorsement Factory Module works in a similar manner, requesting the Selector Module to find out when it has been designated to be an endorsement producer, then feeding new endorsements to the Pool Module and the API Module for global synchronization."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:251
#: 67d56d63bef543c3b736c19580d75676
msgid "Operation lifecycle"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:253
#: 9c56083c3afc43309382497c94f670d8
msgid "We have now all the elements and vocabulary in place to explore the lifecycle of an operation within the network, from creation to permanent execution in a finalized block."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:256
#: 37c1f06cee9845538bdf32af9b6509a3
msgid "Operations originate externally from a client that is forging the operation, for example: a transaction or a smart contract code execution. The client will have to know the IP address of a Massa Node (this can be either because it is a node itself and will simply use localhost, or via some maintained list of known nodes and/or some browser plugin), and will then send the operation to the API Module."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:261
#: 5326c9906161491abbbb392226b6150d
msgid "When an operation is made available in a given node, it will be broadcasted to all other nodes via the Protocol/Network Module and to factories via the API Module, so that it will eventually end up in all the Pool Modules of the network."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:264
#: 7de0de5f16cd4456983df34f4cda53a9
msgid "Let's assume we just got a code execution operation from an external client. Let's suppose the client knows a particular node, which is running its block factory on the same machine, and sends the operation to this node. These are the different steps of the operation processing that will occur, as illustrated in the schema below:"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:268
#: 94589bdd087a4fd18aea6e839e61d3f5
msgid "The operation enters the node via the API Module (the operation path is marked in blue)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:269
#: 9e8c270e8d7e4d26816d4a4d5c6d00db
msgid "The API Module forwards the operation to the Pool Module and broadcasts it to other nodes via the Protocol/Network Module. Other nodes hearing about it will also broadcast it (gossip protocol), and feed it to their Pool Module, unless they are pure consensus nodes without factories"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:272
#: ede71d52cf2a4c408839b4cde060de65
msgid "At that stage, the operation sits in the Pool Modules of most nodes"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:273
#: 4d70f387d30c40dda79259ddb37a7d16
msgid "The Selector Module elects a particular node to handle the block production of the next current slot"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:274
#: 65927a1adb434bb2bc51e0b5cac059ac
msgid "The elected node Block Factory finds out about its election by querying a Selector Module (via the API Module)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:275
#: 2b9012ce2e634c6e9bea185a4bd79e60
msgid "It starts building a block by picking up pending operations in the Pool Module. The original operation is eventually picked and integrated into the block. We will now follow the block around (the block path is marked in green)"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:277
#: a2c09dc95b12463ebca7810f9ae81e44
msgid "The newly produced block is sent via the API to remote or local nodes, to reach the Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:278
#: eb7a884fb6ed44e4af8d9e933bafc9a9
msgid "The new block is processed by the Graph/Consensus Module to be included into the pending blocks DAG and potentially integrated into a new blockclique"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:280
#: 268ab2805a1a4cfba7f73a62b0a62414
msgid "The Graph/Consensus Module sends the new block to other nodes via the Protocol/Network Module, to ensure synchronization of the information in the network. The new block reaching other nodes is similarly going to be integrated into their Graph/Consensus Module"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:283
#: 6e558c8b824b470c81591feaee0b4cf7
msgid "In general, the blockclique will be extended with the new block and so will reach the Execution Module from the Graph/Consensus Module via the notification of a new blockclique. Eventually, it will also be notified as a final block if it gets finalized."
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:286
#: d54eebc8ff9e4e08bf905341c6f04d36
msgid "The Execution Module will run the blocks that are part of the updated blockclique, so the original block will eventually be executed. Within the block is the original operation that was originally sent and that will then be applied to the ledger for potential modifications. At this stage, the modifications are not permanent and simply stored in a diff compared to the finalized ledger"
msgstr ""

#: ../../general-doc/architecture/archi-global.rst:290
#: b3063d07cb2f4248b8e1c3ae7d513565
msgid "Eventually, the block will be marked as final and the ledger modification, including the operation changes, will become final in the finalized ledger."
msgstr ""
